[["programando-con-r.html", "3 Programando con R 3.1 Operadores lógicos 3.2 Consultas lógicas 3.3 Control de flujo 3.4 Funciones 3.5 Funciones de la familia apply 3.6 Gráficos 3.7 Estilo tidyverse", " 3 Programando con R 3.1 Operadores lógicos x &lt;- c(1, 2, 3, 4) Operador Resultado Comparación x &gt; 3 c(F, F, F, T, T) Mayor que x &gt;= 3 c(F, F, T, T, T) Mayor o igual que x &lt; 3 c(T, T, F, F, F) Menor que x &lt;= 3 c(T, T, T, F, F) Menor o igual que x == 3 c(F, F, T, F, F) Igual a x != 3 c(T, T, F, T, T) Diferente de x = 3 Igual que &lt;- Se puede utilizar %in% para preguntar si uno o varios elementos se encuentran en otro, devolviendo lógicos. 1 %in% c(1, 2, 3, 4) 1 %in% c(2, 3, 4) c(3,4,5,6) %in% c(2, 3, 4) Puedes combinar evaluaciones lógicas con &amp;, |, xor, !, any, y all x &gt; 2 &amp; x &lt; 9 Operador Evaluación a &amp; b Tanto a como b son VERDADEROS a | b Al menos uno de a y b es VERDADERO (o) xor(a, b) a es VERDADERO o b es VERDADERO, pero no ambos !a No a (VERDADERO va a FALSO, FALSO va a VERDADERO) any(a, b, c) Al menos uno de a, b o c es VERDADERO all(a, b, c) Cada uno de a, b y c es VERDADERO 3.2 Consultas lógicas Combinar pruebas lógicas con subconjuntos es una práctica común x_ceros &lt;- diamonds$x == 0 diamonds[x_ceros,] ## # A tibble: 8 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1.07 Ideal F SI2 61.6 56 4954 0 6.62 0 ## 2 1 Very Good H VS2 63.3 53 5139 0 0 0 ## 3 1.14 Fair G VS1 57.5 67 6381 0 0 0 ## 4 1.56 Ideal G VS2 62.2 54 12800 0 0 0 ## 5 1.2 Premium D VVS1 62.1 59 15686 0 0 0 ## 6 2.25 Premium H SI2 62.8 59 18034 0 0 0 ## 7 0.71 Good F SI2 64.1 60 2130 0 0 0 ## 8 0.71 Good F SI2 64.1 60 2130 0 0 0 # Ver resultados diamonds[diamonds$x &gt; 10, ] ## # A tibble: 5 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4.01 Premium I I1 61 61 15223 10.1 10.1 6.17 ## 2 4.01 Premium J I1 62.5 62 15223 10.0 9.94 6.24 ## 3 4 Very Good I I1 63.3 58 15984 10.0 9.94 6.31 ## 4 5.01 Fair J I1 65.5 59 18018 10.7 10.5 6.98 ## 5 4.5 Fair J I1 65.8 58 18531 10.2 10.2 6.72 # Guardar un nuevo data.frame big &lt;- diamonds[diamonds$x &gt; 10, ] # Sobreescribir el dataset existente (Cuidado!) diamonds &lt;- diamonds[diamonds$x &lt; 10,] 3.3 Control de flujo ¿Quieres saltar este capítulo? Hazlo si puedes responder estas preguntas. Cuál es la diferencia entre if e ifelse()? En el siguiente código, cuál será el valor de y si x es TRUE? Y cuál sería si x es FALSE? Y cuál si x es NA? y &lt;- if (x) 3 ¿Qué retorna de switch(\"x\", x = , y = 2, z = 3)? Los comandos de control de flujo son una forma de modificar la secuencia de ejecución del código. Existen 2 herramientas principales de flujo de control: Opciones y bucles. Las opciones, como las declaraciones condicionales if y las llamadas switch(), permiten ejecutar código diferente según la entrada. Los bucles, como for y while, le permiten ejecutar código repetidamente, generalmente con opciones cambiantes. 3.3.1 Condicionales (if, else) La toma de decisiones es una parte importante de la programación. Esto se puede lograr en la programación R usando la nomenclatura condicional if else. if (expresion) { declaracion1 }else{ declaracion2 } Si expresion es TRUE, la instrucción se ejecuta. Pero si es FALSO, no pasa nada. Aquí, expresion puede ser un vector lógico o numérico, pero solo se tiene en cuenta el primer elemento. En el caso del vector numérico, cero se toma como FALSO, el resto como VERDADERO. La parte else es opcional y solo se evalúa si expresion es FALSE. Es importante tener en cuenta que else debe estar en la misma línea que las llaves de cierre de la instrucción if. x &lt;- 0 if (x &lt; 0) { print(&quot;Numero negativo&quot;) }else if (x &gt; 0) { print(&quot;Numero positivo&quot;) } else { print(&quot;Cero&quot;) } ## [1] &quot;Cero&quot; Comparación entre Python y R ## PYTHON temp = [15, 22, 30] suelo= [&quot;seco&quot;, &quot;humedo&quot;, &quot;charcos&quot;] valtemp = temp[0] valsuelo= suelo[2] if 12&lt;= valtemp &lt; 22 and valsuelo ==&quot;seco&quot;: print(&quot;Cielo despejado&quot;) elif valtemp == 22 or valsuelo == &quot;humedo&quot;: print(&quot;lluvia leve&quot;) elif valtemp &gt; 22 and valsuelo==&quot;charcos&quot;: print(&quot;lluvia severa&quot;) else: print(&quot; Faltan datos&quot;) ## Faltan datos ## R temp &lt;- c(15, 22, 30) suelo &lt;- c(&quot;seco&quot;, &quot;humedo&quot;, &quot;charcos&quot;) valtemp &lt;- temp[1] valsuelo &lt;- suelo[3] if (valtemp %in% 12:22 &amp; valsuelo ==&quot;seco&quot;) { print(&quot;\\nCielo despejado&quot;) } else if (valtemp == 22 | valsuelo == &quot;humedo&quot;){ print(&quot;\\nlluvia leve&quot;) } else if (valtemp &gt; 22 &amp; valsuelo==&quot;charcos&quot;){ print(&quot;\\nlluvia severa&quot;) } else { print(&quot;\\nFaltan datos&quot;) } ## [1] &quot;\\nFaltan datos&quot; 3.3.2 Bucles (while, for) Los bucles son una de las estructuras fundamentales en la programación. Los bucles permiten iterar sobre cada elemento en una secuencia, uno a la vez, y hacer algo con esos elementos. 3.3.2.1 for Un bucle for es muy valioso cuando necesitamos iterar sobre una lista de elementos o un rango de números. Loop se puede usar para iterar sobre una lista, marco de datos, vector, matriz o cualquier otro objeto. Los tirantes y el corchete son obligatorios. for (valor in secuencia) { cuerpo } # Creando un vector de frutas frutas &lt;- c(&#39;Apple&#39;, &#39;Orange&#39;, &#39;Passion fruit&#39;, &#39;Banana&#39;) # Declarando el bucle for for ( i in frutas){ print(i) } ## [1] &quot;Apple&quot; ## [1] &quot;Orange&quot; ## [1] &quot;Passion fruit&quot; ## [1] &quot;Banana&quot; 3.3.2.2 while Un bucle while es una declaración que continúa ejecutándose mientras se cumple una condición. La sintaxis para un ciclo while es la siguiente: while (condición) { cuerpo } # creando la expresión con valor 1 inicio &lt;- 1 # Creando el loop while (inicio &lt;= 5){ # Ver donde estamos cat(&#39;Este es el ciclo número &#39;, inicio) # Agregar 1 a la variable inicio despues de cada iteracion inicio &lt;- inicio + 1 print(inicio) } ## Este es el ciclo número 1[1] 2 ## Este es el ciclo número 2[1] 3 ## Este es el ciclo número 3[1] 4 ## Este es el ciclo número 4[1] 5 ## Este es el ciclo número 5[1] 6 3.3.3 Controles de flujo (Break, continue, tryCatch, options) 3.4 Funciones Una función, en un entorno de programación, es un conjunto de instrucciones. Un programador crea una función para evitar repetir la misma tarea o reducir la complejidad. Una función debería ser: Escrito para llevar a cabo una tarea específica Puede o no incluir argumentos Contener un cuerpo Puede o no devolver uno o más valores function (argumentos) { # cuerpo de la funcion resultado &lt;- cuerpo return(resultado) } Ejemplo: a &lt;- 5 b &lt;- 6 suma &lt;- function(valor1, valor2){ resultado &lt;- valor1 + valor2 return(resultado) } suma(a, b) ## [1] 11 3.4.1 Ejercicios 3.4.1.1 Ejercicio 1: Cree una función que, dado un vector, imprima por pantalla la media y la desviación estándar, opcionalmente también imprimirá la mediana. 3.4.1.2 Ejercicio 2: Agregar un argumento adicional, llamado print_info, que sea TRUE por defecto Crea una condicional alrededor de la función print(), la cual debe ser ejecutada sólo si print_info es TRUE Prueba el código # Finaliza la funcion pow_two() pow_two &lt;- function(x) { y &lt;- x ^ 2 print(paste(x, &quot;to the power two equals&quot;, y)) return(y) } 3.5 Funciones de la familia apply Los apply: apply, tapply, lapply, sapply, vapply, rapply Entonces, ¿cuáles son estas maravillosas funciones de aplicación y cómo funcionan? Creo que la mejor manera de descubrir cualquier cosa en R es aprender mediante la experimentación, utilizando datos y funciones vergonzosamente triviales. If you fire up your R console, type “??apply” and scroll down to the functions in the base package, you’ll see something like this: d &lt;- read.csv(&quot;data/earthquakes.csv&quot;) str(d) head(d) 3.5.1 apply(): APLICA RESUMENES SOBRE MARGENES. 1=SOBRE FILAS, 2=SOBRE COLUMNAS apply(d[,2:5], 2, mean, na.rm = T) apply(d[,2:5], 2, median, na.rm = T) apply(d[,2:5], 2, summary) 3.5.2 tapply() APLICA FUNCION SOBRE MATRICES/TABLAS DESIGUALES EN LAS QUE SE USA UNA VARIABLE DE AGRUPAMIENTO O INDICE unique(d$Source) tapply(d$Magnitude, d$Latitude, mean, na.rm = T) tapply(d$Magnitude, d$Source, mean, na.rm = T) with(d, tapply(Magnitude, Latitude, mean, na.rm = T)) with(d, tapply(Magnitude, Longitude, summary)) with(d, tapply(Magnitude, Source, summary)) 3.5.3 lapply() sapply() vapply() APLICA FUNCION SOBRE VECTORES/LISTAS lapply() DEVUELVE UNA LISTA str(d) head(d) lapply(d, mean, na.rm = T) lapply(data.frame(a=10:20,b=15:25), mean) d[1:6,] d[1:6, c(12,2:5)] lapply(d[,c(12,2:5)], mean, na.rm = T) lapply(d[,c(12,2:5)], summary, na.rm = T) 3.5.4 sapply() DEVUELVE UN VECTOR O UNA TABLA levels(as.factor(d$Source)) sapply(d[,c(12,2:5)], mean, na.rm = T) sapply(d[,c(12,2:5)], summary, na.rm = T) funcion_nueva &lt;- function(x){ sapply(d[d$Source==x, c(12,2:5)], summary) } levels(as.factor(d$Source)) sapply(levels(as.factor(d$Source)), funcion_nueva, simplify = F) 3.5.5 vapply() SIMILAR, PERO DEVUELVE UNA SALIDA PREDETERMINADA QUE PODRIA RESULTAR MAS AGIL vapply(d[,c(12,2:5)], mean, na.rm = T, c(&#39;Mean&#39;=0)) vapply(d[,c(12,2:5)], fivenum, na.rm = T, c(&quot;Min.&quot;=0,&quot;1st Qu.&quot;=0, &quot;Median&quot;=0, &quot;3rd Qu.&quot;=0, &quot;Max.&quot;=0)) 3.5.6 rapply() SIMILAR, PERO DEVUELVE UNA SALIDA QUE PUEDE CONSERVAR ESTRUCTURA ORIGINAL O LISTA rapply(d[,2:5], summary) rapply(d[,2:5], summary, how = &#39;list&#39;) Para profundizar, se recomienda seguir esta Fuente 3.6 Gráficos # Scatter plots x &lt;- 1:12 y &lt;- c(27, 28, 26, 22, 19, 16, 14, 13, 14, 16, 20, 23) estaciones &lt;- c(rep(&quot;verano&quot;,2), rep(&quot;otoño&quot;,3), rep(&quot;invierno&quot;,3), rep(&quot;primavera&quot;,3), &quot;verano&quot;) df &lt;- data.frame(x, y, estaciones) plot(df$x, df$y, type=&quot;o&quot;, pch=14,xlab = &quot;Mes&quot;, ylab = &quot;Temperatura [°C]&quot;, main=&quot;Lima, Temperatura mensual promedio&quot;) plot(df$x, df$y, type=&quot;o&quot;, pch=20, xlab=&quot;Mes&quot;, ylab=&quot;Temperatura [°C]&quot;, main=&quot;Lima, Temperatura mensual promedio&quot;, col = &quot;#F47E40&quot;) df[&quot;colores&quot;] = c(rep(&quot;black&quot;,2), rep(&quot;green&quot;,3), rep(&quot;red&quot;,3), rep(&quot;blue&quot;,3), &quot;red&quot;) legend(&quot;top&quot;, legend = levels(factor(estaciones)), col = c(&quot;black&quot;, &quot;green&quot;, &quot;red&quot;, &quot;blue&quot;), pch = c(16, 17, 18) ) data(cars) plot(cars$speed, cars$dist, xlab = &quot;Velocidad&quot;, ylab = &quot;Distancia&quot;, main = &quot;Velocidad vs distancia&quot;) # Histogram # hist(cars$speed) # hist(cars$speed, breaks = 10) hist(cars$dist, freq = T, col = &quot;skyblue&quot;, labels = T) 3.7 Estilo tidyverse Primero necesitarás instalar algunos paquetes de R. Un paquete R es una colección de funciones, datos y documentación que amplía las capacidades de R base. El uso de paquetes es clave para el uso exitoso de R. La mayoría de los paquetes que aprenderá en este apartado son parte del llamado tidyverse. Los paquetes de tidyverse comparten una filosofía común de programación de datos y R, y están diseñados para trabajar juntos de forma natural. Puedes instalar tidyverse completo con una sola línea de código: install.packages(&quot;tidyverse&quot;) En su propia computadora, escriba esa línea de código en la consola y luego presione Entrar para ejecutarlo. R descargará los paquetes de CRAN y los instalará en su computadora. Si tiene problemas con la instalación, asegúrese de estar conectado a Internet y de que https://cloud.r-project.org/ no esté bloqueado por su firewall o proxy. No podrá utilizar las funciones, los objetos y los archivos de ayuda de un paquete hasta que lo cargue con library(). Una vez que haya instalado un paquete, puede cargarlo con la función library(): library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ── ## ✓ ggplot2 3.3.3 ✓ purrr 0.3.4 ## ✓ tibble 3.1.2 ✓ dplyr 1.0.6 ## ✓ tidyr 1.1.3 ✓ stringr 1.4.0 ## ✓ readr 1.4.0 ✓ forcats 0.5.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() Esto le indica que tidyverse está cargando los paquetes ggplot2, tibble, tidyr, readr, purrr y dplyr. Estos consideran los núcleo del tidyverse porque los usará en casi todos los análisis. Los paquetes del tidyverse cambian con bastante frecuencia. Puede ver si hay actualizaciones disponibles y, opcionalmente, instalarlas, ejecutando tidyverse_update(). Toma nota del mensaje de conflictos que se imprime cuando cargas el tidyverse. Te dice que dplyr sobrescribe algunas funciones en base R. Si desea usar la versión base de estas funciones después de cargar dplyr, deberá usar sus nombres completos: stats::filter() y stats::lag() 3.7.1 Data Transformation con dplyr La visualización es una herramienta importante para la generación de información, pero es raro que obtenga los datos exactamente en la forma correcta que necesita. A menudo, necesitará crear algunas variables o resúmenes nuevos, o tal vez solo desee cambiar el nombre de las variables o reordenar las observaciones para que sea un poco más fácil trabajar con los datos. Aprenderá a hacer todo eso (¡y más!) en este apartado, que le enseñará cómo transformar sus datos utilizando el paquete dplyr y un nuevo conjunto de datos sobre vuelos que parten de la ciudad de Nueva York en 2013. En este capítulo, nos centraremos en cómo usar el paquete dplyr, otro miembro central de tidyverse. Ilustraremos las ideas clave usando datos del paquete nycflights13 y usar ggplot2 para ayudarnos a comprender los datos. library(nycflights13) 3.7.1.1 nycfights13 Para explorar los verbos básicos de manipulación de datos de dplyr, usaremos nycflights13::flights. Este marco de datos contiene los 336,776 vuelos que partieron de la ciudad de Nueva York en 2013. Los datos provienen de la oficina Oficina de Estadísticas de Transporte de EE. UU, y están documentados en ?flights: flights ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Es posible que observe que este dataframe se imprima un poco diferente de otros dataframe que podría haber usado en el pasado: solo muestra las primeras filas y todas las columnas que caben en una pantalla. (Para ver el conjunto de datos completo, puede ejecutar View(flights), que abrirá el conjunto de datos en el visor de RStudio). Se imprime de manera diferente porque es un tibble. Tibbles son dataframe, pero ligeramente modificados para que funcionen mejor en tidyverse. Por ahora, no necesita preocuparse por las diferencias; volveremos a tibbles con más detalle en la Parte II del libro de Hadley Wickham y Garrett Grolemund (2017). También puede haber notado la fila de abreviaturas de tres (o cuatro) letras debajo de los nombres de las columnas. Estos describen el tipo de cada variable: int significa enteros. dbl significa dobles o números reales. chr significa vectores de caracteres o cadenas. dttm significa fecha y hora (una fecha + una hora). Hay otros tres tipos comunes de variables que no se utilizan en este conjunto de datos, pero los encontrará más adelante en el libro de libro de Hadley Wickham y Garrett Grolemund (2017): lgl significa vectores lógicos que contienen solo VERDADERO o FALSO. fctr significa factores, que R usa para representar categóricos variables con valores posibles fijos. date representa fechas. 3.7.1.2 dplyr Basics En este capítulo, aprenderá las cinco funciones clave de dplyr que le permiten resolver la gran mayoría de sus desafíos de manipulación de datos: Elija observaciones por sus valores (filter()). Reordenar las filas (arrange()). Elija las variables por sus nombres (select()). Crear nuevas variables con funciones de variables existentes (mutate()). Colapsar muchos valores en un solo resumen (summarize()) "]]

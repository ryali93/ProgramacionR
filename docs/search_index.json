[["programando-con-r.html", "3 Programando con R 3.1 Operadores relacionales y lógicos 3.2 Consultas lógicas 3.3 Control de flujo 3.4 Funciones 3.5 Funciones de la familia apply 3.6 Gráficos 3.7 Estilo tidyverse 3.8 Gráficos con ggplot", " 3 Programando con R 3.1 Operadores relacionales y lógicos Los operadores de comparación o relacionales están diseñados para comparar objetos. El resultado de estas comparaciones son de tipo booleano. La siguiente tabla resume los operadores relacionales de R. x &lt;- c(1, 2, 3, 4) Operador Resultado Comparación x &gt; 3 c(F, F, F, T, T) Mayor que x &gt;= 3 c(F, F, T, T, T) Mayor o igual que x &lt; 3 c(T, T, F, F, F) Menor que x &lt;= 3 c(T, T, T, F, F) Menor o igual que x == 3 c(F, F, T, F, F) Igual a x != 3 c(T, T, F, T, T) Diferente de x = 3 Igual que &lt;- Se puede utilizar %in% para preguntar si uno o varios elementos se encuentran en otro, devolviendo lógicos. 1 %in% c(1, 2, 3, 4) 1 %in% c(2, 3, 4) c(3,4,5,6) %in% c(2, 3, 4) Los operadores booleanos o lógicos en R se utilizan para especificar múltiples condiciones entre objetos. Estas comparaciones devuelven valores TRUE o FALSE. Puedes combinar evaluaciones lógicas con &amp;, |, xor, !, any, y all x &gt; 2 &amp; x &lt; 9 Operador Evaluación a &amp; b Tanto a como b son VERDADEROS a | b Al menos uno de a y b es VERDADERO (o) xor(a, b) a es VERDADERO o b es VERDADERO, pero no ambos !a No a (VERDADERO va a FALSO, FALSO va a VERDADERO) any(a, b, c) Al menos uno de a, b o c es VERDADERO all(a, b, c) Cada uno de a, b y c es VERDADERO 3.2 Consultas lógicas Combinar pruebas lógicas con subconjuntos es una práctica común x_ceros &lt;- diamonds$x == 0 diamonds[x_ceros, ] ## # A tibble: 8 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1.07 Ideal F SI2 61.6 56 4954 0 6.62 0 ## 2 1 Very Good H VS2 63.3 53 5139 0 0 0 ## 3 1.14 Fair G VS1 57.5 67 6381 0 0 0 ## 4 1.56 Ideal G VS2 62.2 54 12800 0 0 0 ## 5 1.2 Premium D VVS1 62.1 59 15686 0 0 0 ## 6 2.25 Premium H SI2 62.8 59 18034 0 0 0 ## 7 0.71 Good F SI2 64.1 60 2130 0 0 0 ## 8 0.71 Good F SI2 64.1 60 2130 0 0 0 # Ver resultados diamonds[diamonds$x &gt; 10, ] ## # A tibble: 5 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4.01 Premium I I1 61 61 15223 10.1 10.1 6.17 ## 2 4.01 Premium J I1 62.5 62 15223 10.0 9.94 6.24 ## 3 4 Very Good I I1 63.3 58 15984 10.0 9.94 6.31 ## 4 5.01 Fair J I1 65.5 59 18018 10.7 10.5 6.98 ## 5 4.5 Fair J I1 65.8 58 18531 10.2 10.2 6.72 # Guardar un nuevo data.frame big &lt;- diamonds[diamonds$x &gt; 10, ] # Sobreescribir el dataset existente (Cuidado!) diamonds &lt;- diamonds[diamonds$x &lt; 10, ] 3.3 Control de flujo ¿Quieres saltar este capítulo? Hazlo si puedes responder estas preguntas. Cuál es la diferencia entre if e ifelse()? En el siguiente código, cuál será el valor de y si x es TRUE? Y cuál sería si x es FALSE? Y cuál si x es NA? y &lt;- if (x) 3 Los comandos de control de flujo son una forma de modificar la secuencia de ejecución del código. Existen 2 herramientas principales de flujo de control: Opciones y bucles. Las opciones, como las declaraciones condicionales if y las llamadas switch(), permiten ejecutar código diferente según la entrada. Los bucles, como for y while, le permiten ejecutar código repetidamente, generalmente con opciones cambiantes. 3.3.1 Condicionales (if, else) La toma de decisiones es una parte importante de la programación. Esto se puede lograr en la programación R usando la nomenclatura condicional if else. if (expresion) { declaracion1 } else { declaracion2 } Si expresion es TRUE, la instrucción se ejecuta. Pero si es FALSO, no pasa nada. Aquí, expresion puede ser un vector lógico o numérico, pero solo se tiene en cuenta el primer elemento. En el caso del vector numérico, cero se toma como FALSO, el resto como VERDADERO. La parte else es opcional y solo se evalúa si expresion es FALSE. Es importante tener en cuenta que else debe estar en la misma línea que las llaves de cierre de la instrucción if. x &lt;- 0 if (x &lt; 0) { print(&quot;Numero negativo&quot;) } else if (x &gt; 0) { print(&quot;Numero positivo&quot;) } else { print(&quot;Cero&quot;) } ## [1] &quot;Cero&quot; Comparación entre Python y R ## PYTHON temp = [15, 22, 30] suelo = [&quot;seco&quot;, &quot;humedo&quot;, &quot;charcos&quot;] valtemp = temp[0] valsuelo = suelo[2] if 12&lt;= valtemp &lt; 22 and valsuelo ==&quot;seco&quot;: print(&quot;Cielo despejado&quot;) elif valtemp == 22 or valsuelo == &quot;humedo&quot;: print(&quot;lluvia leve&quot;) elif valtemp &gt; 22 and valsuelo ==&quot;charcos&quot;: print(&quot;lluvia severa&quot;) else: print(&quot; Faltan datos&quot;) ## Faltan datos ## R temp &lt;- c(15, 22, 30) suelo &lt;- c(&quot;seco&quot;, &quot;humedo&quot;, &quot;charcos&quot;) valtemp &lt;- temp[1] valsuelo &lt;- suelo[3] if (valtemp %in% 12:22 &amp; valsuelo == &quot;seco&quot;) { print(&quot;\\nCielo despejado&quot;) } else if (valtemp == 22 | valsuelo == &quot;humedo&quot;) { print(&quot;\\nlluvia leve&quot;) } else if (valtemp &gt; 22 &amp; valsuelo == &quot;charcos&quot;) { print(&quot;\\nlluvia severa&quot;) } else { print(&quot;\\nFaltan datos&quot;) } ## [1] &quot;\\nFaltan datos&quot; 3.3.2 Bucles (while, for) Los bucles son una de las estructuras fundamentales en la programación. Los bucles permiten iterar sobre cada elemento en una secuencia, uno a la vez, y hacer algo con esos elementos. 3.3.2.1 for Un bucle for es muy valioso cuando necesitamos iterar sobre una lista de elementos o un rango de números. Loop se puede usar para iterar sobre una lista, marco de datos, vector, matriz o cualquier otro objeto. Los tirantes y el corchete son obligatorios. for (valor in secuencia) { cuerpo } # Creando un vector de frutas frutas &lt;- c(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Passion fruit&quot;, &quot;Banana&quot;) # Declarando el bucle for for (i in frutas) { print(i) } ## [1] &quot;Apple&quot; ## [1] &quot;Orange&quot; ## [1] &quot;Passion fruit&quot; ## [1] &quot;Banana&quot; 3.3.2.2 while Un bucle while es una declaración que continúa ejecutándose mientras se cumple una condición. La sintaxis para un ciclo while es la siguiente: while (condición) { cuerpo } # creando la expresión con valor 1 inicio &lt;- 1 # Creando el loop while (inicio &lt;= 5) { # Ver donde estamos cat(&quot;Este es el ciclo número &quot;, inicio) # Agregar 1 a la variable inicio despues de cada iteracion inicio &lt;- inicio + 1 print(inicio) } ## Este es el ciclo número 1[1] 2 ## Este es el ciclo número 2[1] 3 ## Este es el ciclo número 3[1] 4 ## Este es el ciclo número 4[1] 5 ## Este es el ciclo número 5[1] 6 3.3.3 Control de flujo 3.3.3.1 break Se usa una declaración break dentro de un bucle (repeat, for, while) para detener las iteraciones y hacer fluir el control fuera del bucle. En una situación de bucle anidado, donde hay un bucle dentro de otro bucle, esta declaración sale del bucle más interno que se está evaluando. if (test_expression) { break } Nota: la instrucción break también se puede usar dentro de la rama else de la instrucción if … else. x &lt;- 1:5 for (val in x) { if (val == 3){ break } print(val) } ## [1] 1 ## [1] 2 En este ejemplo, iteramos sobre el vector x, que tiene números consecutivos del 1 al 5. Dentro del ciclo for hemos usado una condición if para romper si el valor actual es igual a 3. Como podemos ver en la salida, el bucle termina cuando encuentra la declaración break. 3.3.3.2 next Una declaración next es útil cuando queremos omitir la iteración actual de un ciclo sin terminarlo. Al encontrar el siguiente, R omite una evaluación adicional y comienza la siguiente iteración del ciclo. if (test_condition) { next } x &lt;- 1:5 for (val in x) { if (val == 3){ next } print(val) } ## [1] 1 ## [1] 2 ## [1] 4 ## [1] 5 En el ejemplo anterior, usamos la siguiente declaración dentro de una condición para verificar si el valor es igual a 3. Si el valor es igual a 3, la evaluación actual se detiene (el valor no se imprime) pero el ciclo continúa con la siguiente iteración. 3.4 Funciones Una función, en un entorno de programación, es un conjunto de instrucciones. Un programador crea una función para evitar repetir la misma tarea o reducir la complejidad. Una función debería ser: Escrito para llevar a cabo una tarea específica Puede o no incluir argumentos Contener un cuerpo Puede o no devolver uno o más valores function(argumentos) { # cuerpo de la funcion resultado &lt;- cuerpo return(resultado) } Ejemplo: a &lt;- 5 b &lt;- 6 suma &lt;- function(valor1, valor2) { resultado &lt;- valor1 + valor2 return(resultado) } suma(a, b) ## [1] 11 3.4.1 Ejercicios 3.4.1.1 Ejercicio 1: Cree una función que, dado un vector, imprima por pantalla la media y la desviación estándar, opcionalmente también imprimirá la mediana. 3.4.1.2 Ejercicio 2: Agregar un argumento adicional, llamado print_info, que sea TRUE por defecto Crea una condicional alrededor de la función print(), la cual debe ser ejecutada sólo si print_info es TRUE Prueba el código # Finaliza la funcion pow_two() pow_two &lt;- function(x) { y &lt;- x^2 print(paste(x, &quot;to the power two equals&quot;, y)) return(y) } 3.5 Funciones de la familia apply Los apply: apply, tapply, lapply, sapply, vapply, rapply Entonces, ¿cuáles son estas maravillosas funciones de aplicación y cómo funcionan? Creo que la mejor manera de descubrir cualquier cosa en R es aprender mediante la experimentación, utilizando datos y funciones vergonzosamente triviales. If you fire up your R console, type “??apply” and scroll down to the functions in the base package, you’ll see something like this: d &lt;- read.csv(&quot;data/earthquakes.csv&quot;) str(d) head(d) 3.5.1 apply(): Crea resúmenes sobre los ejes. 1: Sobre filas, 2: Sobre columnas apply(d[, 2:5], 2, mean, na.rm = T) apply(d[, 2:5], 2, median, na.rm = T) apply(d[, 2:5], 2, summary) 3.5.2 tapply() Esta función trabaja sobre matrices o tablas desiguales y usa una variable de agrupamiento o índice. unique(d$Source) tapply(d$Magnitude, d$Latitude, mean, na.rm = T) tapply(d$Magnitude, d$Source, mean, na.rm = T) with(d, tapply(Magnitude, Latitude, mean, na.rm = T)) with(d, tapply(Magnitude, Longitude, summary)) with(d, tapply(Magnitude, Source, summary)) 3.5.3 lapply() Esta función es aplicable a vectores y listas y permite generar resúmenes como listas str(d) head(d) lapply(d, mean, na.rm = T) lapply(data.frame(a = 10:20, b = 15:25), mean) d[1:6, ] d[1:6, c(12, 2:5)] lapply(d[, c(12, 2:5)], mean, na.rm = T) lapply(d[, c(12, 2:5)], summary, na.rm = T) 3.5.4 sapply() Crea resúmenes como vector o tabla levels(as.factor(d$Source)) sapply(d[, c(12, 2:5)], mean, na.rm = T) sapply(d[, c(12, 2:5)], summary, na.rm = T) funcion_nueva &lt;- function(x) { sapply(d[d$Source == x, c(12, 2:5)], summary) } levels(as.factor(d$Source)) sapply(levels(as.factor(d$Source)), funcion_nueva, simplify = F) 3.5.5 vapply() Similar al anterior, pero devuelve una salida predeterminada (puede ser más práctico) vapply(d[, c(12, 2:5)], mean, na.rm = T, c(&quot;Mean&quot; = 0)) vapply(d[, c(12, 2:5)], fivenum, na.rm = T, c(&quot;Min.&quot; = 0, &quot;1st Qu.&quot; = 0, &quot;Median&quot; = 0, &quot;3rd Qu.&quot; = 0, &quot;Max.&quot; = 0)) 3.5.6 rapply() Similar al anterior, per devuelve una salida que conserva la estructura original rapply(d[, 2:5], summary) rapply(d[, 2:5], summary, how = &quot;list&quot;) Para profundizar, se recomienda seguir esta Fuente 3.6 Gráficos 3.6.1 Gráficos de dispersión # Scatter plots x &lt;- 1:12 y &lt;- c(27, 28, 26, 22, 19, 16, 14, 13, 14, 16, 20, 23) estaciones &lt;- c(rep(&quot;verano&quot;, 2), rep(&quot;otoño&quot;, 3), rep(&quot;invierno&quot;, 3), rep(&quot;primavera&quot;, 3), &quot;verano&quot;) df &lt;- data.frame(x, y, estaciones) plot( df$x, df$y, type = &quot;o&quot;, pch = 14, xlab = &quot;Mes&quot;, ylab = &quot;Temperatura [°C]&quot;, main = &quot;Lima, Temperatura mensual promedio&quot; ) 3.6.2 Gráficos de líneas plot( df$x, df$y, type = &quot;o&quot;, pch = 20, xlab = &quot;Mes&quot;, ylab = &quot;Temperatura [°C]&quot;, main = &quot;Lima, Temperatura mensual promedio&quot;, col = &quot;#F47E40&quot; ) df[&quot;colores&quot;] &lt;- c(rep(&quot;black&quot;, 2), rep(&quot;green&quot;, 3), rep(&quot;red&quot;, 3), rep(&quot;blue&quot;, 3), &quot;red&quot;) legend(&quot;top&quot;, legend = levels(factor(estaciones)), col = c(&quot;black&quot;, &quot;green&quot;, &quot;red&quot;, &quot;blue&quot;), pch = c(16, 17, 18) ) data(cars) plot( cars$speed, cars$dist, xlab = &quot;Velocidad&quot;, ylab = &quot;Distancia&quot;, main = &quot;Velocidad vs distancia&quot; ) # Histogram # hist(cars$speed) # hist(cars$speed, breaks = 10) hist(cars$dist, freq = T, col = &quot;skyblue&quot;, labels = T) breaks_hist &lt;- hist(cars$dist, breaks = 20, plot = FALSE)$breaks hist(cars$dist, breaks = breaks_hist, col = &quot;blue1&quot;) equakes &lt;- read.csv(&quot;data/earthquakes.csv&quot;) # Boxplot boxplot(cars$speed, cars$dist) boxplot(`Magnitude` ~ `Source`, equakes, col = palette(rainbow(2))) # Multiples plots en un grafico dev.new() dev.off() ## png ## 2 par(mfrow = c(2, 2)) 3.7 Estilo tidyverse Primero necesitarás instalar algunos paquetes de R. Un paquete R es una colección de funciones, datos y documentación que amplía las capacidades de R base. El uso de paquetes es clave para el uso exitoso de R. La mayoría de los paquetes que aprenderá en este apartado son parte del llamado tidyverse. Los paquetes de tidyverse comparten una filosofía común de programación de datos y R, y están diseñados para trabajar juntos de forma natural. Puedes instalar tidyverse completo con una sola línea de código: install.packages(&quot;tidyverse&quot;) En su propia computadora, escriba esa línea de código en la consola y luego presione Entrar para ejecutarlo. R descargará los paquetes de CRAN y los instalará en su computadora. Si tiene problemas con la instalación, asegúrese de estar conectado a Internet y de que https://cloud.r-project.org/ no esté bloqueado por su firewall o proxy. No podrá utilizar las funciones, los objetos y los archivos de ayuda de un paquete hasta que lo cargue con library(). Una vez que haya instalado un paquete, puede cargarlo con la función library(): library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ── ## ✓ ggplot2 3.3.5 ✓ purrr 0.3.4 ## ✓ tibble 3.1.2 ✓ dplyr 1.0.7 ## ✓ tidyr 1.1.3 ✓ stringr 1.4.0 ## ✓ readr 1.4.0 ✓ forcats 0.5.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() Esto le indica que tidyverse está cargando los paquetes ggplot2, tibble, tidyr, readr, purrr y dplyr. Estos consideran los núcleo del tidyverse porque los usará en casi todos los análisis. Los paquetes del tidyverse cambian con bastante frecuencia. Puede ver si hay actualizaciones disponibles y, opcionalmente, instalarlas, ejecutando tidyverse_update(). Toma nota del mensaje de conflictos que se imprime cuando cargas el tidyverse. Te dice que dplyr sobrescribe algunas funciones en base R. Si desea usar la versión base de estas funciones después de cargar dplyr, deberá usar sus nombres completos: stats::filter() y stats::lag() 3.7.1 Data Transformation con dplyr La visualización es una herramienta importante para la generación de información, pero es raro que obtenga los datos exactamente en la forma correcta que necesita. A menudo, necesitará crear algunas variables o resúmenes nuevos, o tal vez solo desee cambiar el nombre de las variables o reordenar las observaciones para que sea un poco más fácil trabajar con los datos. Aprenderá a hacer todo eso (¡y más!) en este apartado, que le enseñará cómo transformar sus datos utilizando el paquete dplyr y un nuevo conjunto de datos sobre vuelos que parten de la ciudad de Nueva York en 2013. En este capítulo, nos centraremos en cómo usar el paquete dplyr, otro miembro central de tidyverse. Ilustraremos las ideas clave usando datos del paquete nycflights13 y usar ggplot2 para ayudarnos a comprender los datos. library(nycflights13) 3.7.1.1 nycfights13 Para explorar los verbos básicos de manipulación de datos de dplyr, usaremos nycflights13::flights. Este marco de datos contiene los 336,776 vuelos que partieron de la ciudad de Nueva York en 2013. Los datos provienen de la oficina Oficina de Estadísticas de Transporte de EE. UU, y están documentados en ?flights: flights ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Es posible que observe que este dataframe se imprima un poco diferente de otros dataframe que podría haber usado en el pasado: solo muestra las primeras filas y todas las columnas que caben en una pantalla. (Para ver el conjunto de datos completo, puede ejecutar View(flights), que abrirá el conjunto de datos en el visor de RStudio). Se imprime de manera diferente porque es un tibble. Tibbles son dataframe, pero ligeramente modificados para que funcionen mejor en tidyverse. Por ahora, no necesita preocuparse por las diferencias; volveremos a tibbles con más detalle en la Parte II del libro de Hadley Wickham y Garrett Grolemund (2017). También puede haber notado la fila de abreviaturas de tres (o cuatro) letras debajo de los nombres de las columnas. Estos describen el tipo de cada variable: int significa enteros. dbl significa dobles o números reales. chr significa vectores de caracteres o cadenas. dttm significa fecha y hora (una fecha + una hora). Hay otros tres tipos comunes de variables que no se utilizan en este conjunto de datos, pero los encontrará más adelante en el libro de libro de Hadley Wickham y Garrett Grolemund (2017): lgl significa vectores lógicos que contienen solo VERDADERO o FALSO. fctr significa factores, que R usa para representar categóricos variables con valores posibles fijos. date representa fechas. 3.7.1.2 dplyr Basics En este capítulo, aprenderá las cinco funciones clave de dplyr que le permiten resolver la gran mayoría de sus desafíos de manipulación de datos: Elija observaciones por sus valores (filter()). Reordenar las filas (arrange()). Elija las variables por sus nombres (select()). Crear nuevas variables con funciones de variables existentes (mutate()). Colapsar muchos valores en un solo resumen (summarize()) Todos estos se pueden usar junto con group_by(), que cambia el alcance de cada función de operar en todo el conjunto de datos a operar en él grupo por grupo. Estas seis funciones proporcionan los verbos para un lenguaje de manipulación de datos. Todos los verbos funcionan de manera similar: El primer argumento es un marco de datos. Los argumentos siguientes describen qué hacer con el marco de datos, utilizando los nombres de las variables (sin comillas). El resultado es un nuevo dataframe. Juntas, estas propiedades hacen que sea fácil encadenar varios pasos simples para lograr un resultado complejo. Profundicemos y veamos cómo funcionan estos verbos. 3.7.1.3 Filtrar filas con filter() filter() te permite filtrar un subconjunto de observaciones según sus valores. El primer argumento es el nombre del data frame. El segundo y los siguientes argumentos son las expresiones que lo filtran. Por ejemplo, podemos seleccionar todos los vuelos del 1 de enero con: dplyr::filter(flights, month == 1, day == 1) ## # A tibble: 842 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 832 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, ## # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Cuando ejecutas esa línea de código, dplyr ejecuta la operación de filtrado y devuelve un nuevo data frame. Las funciones de dplyr nunca modifican su input, por lo que si deseas guardar el resultado, necesitarás usar el operador de asignación, &lt;-: filter01 &lt;- dplyr::filter(flights, month == 1, day == 1) de otro modo usar el operador “%&lt;&gt;%” de la librería magrittr. R imprime los resultados o los guarda en una variable. Si desea hacer ambas cosas, puede envolver la tarea entre paréntesis: (filter02 &lt;- dplyr::filter(flights, month == 12, day == 25)) ## # A tibble: 719 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 12 25 456 500 -4 649 651 ## 2 2013 12 25 524 515 9 805 814 ## 3 2013 12 25 542 540 2 832 850 ## 4 2013 12 25 546 550 -4 1022 1027 ## 5 2013 12 25 556 600 -4 730 745 ## 6 2013 12 25 557 600 -3 743 752 ## 7 2013 12 25 557 600 -3 818 831 ## 8 2013 12 25 559 600 -1 855 856 ## 9 2013 12 25 559 600 -1 849 855 ## 10 2013 12 25 600 600 0 850 846 ## # … with 709 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, ## # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 3.7.1.3.1 Comparaciones Para usar el filtrado de manera efectiva, debes saber cómo seleccionar las observaciones que deseas utilizando los operadores de comparación. R proporciona el conjunto estándar: &gt;, &gt;=, &lt;, &lt;=, != (no igual) y == (igual). Cuando comienzas con R, el error más fácil de cometer es usar = en lugar de == cuando se busca igualdad. Cuando esto suceda, obtendrás un error informativo: dplyr::filter(flights, month = 1) ## Error: Problem with `filter()` input `..1`. ## x Input `..1` is named. ## ℹ This usually means that you&#39;ve used `=` instead of `==`. ## ℹ Did you mean `month == 1`? Hay otro problema común que puedes encontrar al usar ==: los números de coma flotante. ¡Estos resultados pueden sorprenderte! sqrt(2)^2 == 2 ## [1] FALSE 1 / 49 * 49 == 1 ## [1] FALSE Las computadoras usan aritmética de precisión finita (obviamente, NO pueden almacenar una cantidad infinita de dígitos), así que recuerda que cada número que observas es una aproximación. En lugar de confiar en ==, usa near() (cercano, en inglés): near(sqrt(2)^2, 2) ## [1] TRUE near(1 / 49 * 49, 1) ## [1] TRUE 3.7.1.3.2 Operadores lógicos Si tienes múltiples argumentos para filter() estos se combinan con “y”: cada expresión debe ser verdadera para que una fila se incluya en el output. Para otros tipos de combinaciones necesitarás usar operadores Booleanos: &amp; es “y”, | es “o”, y ! es “no”. La siguiente figura muestra el conjunto completo de operaciones Booleanas. El siguiente código sirve para encontrar todos los vuelos que partieron en noviembre o diciembre: dplyr::filter(flights, month == 11 | month == 12) ## # A tibble: 55,403 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 11 1 5 2359 6 352 345 ## 2 2013 11 1 35 2250 105 123 2356 ## 3 2013 11 1 455 500 -5 641 651 ## 4 2013 11 1 539 545 -6 856 827 ## 5 2013 11 1 542 545 -3 831 855 ## 6 2013 11 1 549 600 -11 912 923 ## 7 2013 11 1 550 600 -10 705 659 ## 8 2013 11 1 554 600 -6 659 701 ## 9 2013 11 1 554 600 -6 826 827 ## 10 2013 11 1 554 600 -6 749 751 ## # … with 55,393 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; El orden de las operaciones no funciona como en español. No puedes escribir filter(flights, month == (11 | 12)), que literalmente puede traducirse como “encuentra todos los vuelos que partieron en noviembre o diciembre”. En cambio, encontrará todos los meses que son iguales a 11 | 12, una expresión que resulta en ‘TRUE’ (verdadero). En un contexto numérico (como aquí), ‘TRUE’ se convierte en uno, por lo que encuentra todos los vuelos en enero, NO en noviembre o diciembre. ¡Esto es bastante confuso! Una manera rápida y útil para resolver este problema es x %in% y (es decir, x en y). Esto seleccionará cada fila donde x es uno de los valores en y. Podríamos usarlo para reescribir el código de arriba: dplyr::filter(flights, month %in% c(11, 12)) ## # A tibble: 55,403 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 11 1 5 2359 6 352 345 ## 2 2013 11 1 35 2250 105 123 2356 ## 3 2013 11 1 455 500 -5 641 651 ## 4 2013 11 1 539 545 -6 856 827 ## 5 2013 11 1 542 545 -3 831 855 ## 6 2013 11 1 549 600 -11 912 923 ## 7 2013 11 1 550 600 -10 705 659 ## 8 2013 11 1 554 600 -6 659 701 ## 9 2013 11 1 554 600 -6 826 827 ## 10 2013 11 1 554 600 -6 749 751 ## # … with 55,393 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; A veces puedes simplificar subconjuntos complicados al recordar la ley de De Morgan: !(x &amp; y) es lo mismo que !x | !y, y !(x | y) es lo mismo que **!x &amp; !y*. Por ejemplo, si deseas encontrar vuelos que no se retrasaron (en llegada o partida) en más de dos horas, puedes usar cualquiera de los dos filtros siguientes: dplyr::filter(flights, !(arr_delay &gt; 120 | dep_delay &gt; 120)) ## # A tibble: 316,050 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 316,040 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; dplyr::filter(flights, arr_delay &lt;= 120, dep_delay &lt;= 120) ## # A tibble: 316,050 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 316,040 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Una característica importante de R que puede hacer que la comparación sea difícil son los valores faltantes, o NA’s (del inglés “no disponibles”). NA representa un valor desconocido, lo que hace que los valores perdidos sean “contagiosos”: casi cualquier operación que involucre un valor desconocido también será desconocida. Si deseas determinar si falta un valor, usa is.na(): is.na(5) ## [1] FALSE is.na(NA) ## [1] TRUE filter() solo incluye filas donde la condición es TRUE; excluye tanto los valores FALSE como NA. Si deseas conservar valores perdidos, solicítalos explícitamente: df &lt;- tibble(x = c(1, NA, 3)) dplyr::filter(df, x &gt; 1) ## # A tibble: 1 x 1 ## x ## &lt;dbl&gt; ## 1 3 dplyr::filter(df, is.na(x) | x &gt; 1) ## # A tibble: 2 x 1 ## x ## &lt;dbl&gt; ## 1 NA ## 2 3 Siempre que empieces a usar en filter() expresiones complejas que tengan varias partes, considera convertirlas en variables explícitas. Eso hace que sea mucho más fácil verificar tu trabajo. Aprenderás cómo crear nuevas variables en breve. Ejercicios 1.Encuentra todos los vuelos que: - Tuvieron un retraso de llegada de dos o más horas - Volaron a Houston (IAH oHOU) - Fueron operados por United, American o Delta - Partieron en invierno del hemisferio sur (julio, agosto y septiembre) - Llegaron más de dos horas tarde, pero no salieron tarde - Se retrasaron por lo menos una hora, pero repusieron más de 30 minutos en vuelo - Partieron entre la medianoche y las 6 a.m. (incluyente) 2. Otra función de dplyr que es útil para usar filtros es between(). ¿Qué hace? ¿Puedes usarla para simplificar el código necesario para responder a los desafíos anteriores? 3. ¿Cuántos vuelos tienen datos faltantes en horario_salida? ¿Qué otras variables tienen valores faltantes? ¿Qué representan estas filas? 4. ¿Por qué NA^0 no es faltante? ¿Por qué NA | TRUE no es faltante? ¿Por qué FALSE &amp; NA no es faltante? ¿Puedes descubrir la regla general? (¡NA * 0 es un contraejemplo complicado!) 3.7.1.4 Reordenar las filas con arrange() arrange()** funciona de manera similar afilter()` excepto que en lugar de seleccionar filas, cambia su orden. La función toma un dataframe** y un conjunto de nombres de columnas (o expresiones más complicadas) para ordenar según ellas. Si proporcionas más de un nombre de columna, cada columna adicional se utilizará para romper empates en los valores de las columnas anteriores: arrange(flights, year, month, day) ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Usa desc() para reordenar por una columna en orden descendente: arrange(flights, desc(arr_delay)) ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 9 641 900 1301 1242 1530 ## 2 2013 6 15 1432 1935 1137 1607 2120 ## 3 2013 1 10 1121 1635 1126 1239 1810 ## 4 2013 9 20 1139 1845 1014 1457 2210 ## 5 2013 7 22 845 1600 1005 1044 1815 ## 6 2013 4 10 1100 1900 960 1342 2211 ## 7 2013 3 17 2321 810 911 135 1020 ## 8 2013 7 22 2257 759 898 121 1026 ## 9 2013 12 5 756 1700 896 1058 2020 ## 10 2013 5 3 1133 2055 878 1250 2215 ## # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Los valores faltantes siempre se ordenan al final: df &lt;- tibble(x = c(5, 2, NA)) arrange(df, x) ## # A tibble: 3 x 1 ## x ## &lt;dbl&gt; ## 1 2 ## 2 5 ## 3 NA arrange(df, desc(x)) ## # A tibble: 3 x 1 ## x ## &lt;dbl&gt; ## 1 5 ## 2 2 ## 3 NA Ejercicios 1. ¿Cómo podrías usar arrange() para ordenar todos los valores faltantes al comienzo? (Sugerencia: usa is.na()). 2. Ordena vuelos para encontrar los vuelos más retrasados. Encuentra los vuelos que salieron más temprano. 3. Ordena vuelos para encontrar los vuelos más rápidos (que viajaron a mayor velocidad). 4. ¿Cuáles vuelos viajaron más lejos? ¿Cuál viajó más cerca? 3.7.1.5 Seleccionar columnas con select() No es raro obtener conjuntos de datos con cientos o incluso miles de variables. En este caso, el primer desafío a menudo se reduce a las variables que realmente te interesan. select() te permite seleccionar rápidamente un subconjunto útil utilizando operaciones basadas en los nombres de las variables. select() no es muy útil con los datos de los vuelos porque solo tenemos 19 variables, pero de todos modos se entiende la idea general: # Seleccionar columnas por nombre dplyr::select(flights, year, month, day) ## # A tibble: 336,776 x 3 ## year month day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 ## 2 2013 1 1 ## 3 2013 1 1 ## 4 2013 1 1 ## 5 2013 1 1 ## 6 2013 1 1 ## 7 2013 1 1 ## 8 2013 1 1 ## 9 2013 1 1 ## 10 2013 1 1 ## # … with 336,766 more rows # Seleccionar todas las columnas entre anio y dia (incluyente) dplyr::select(flights, year:day) ## # A tibble: 336,776 x 3 ## year month day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 ## 2 2013 1 1 ## 3 2013 1 1 ## 4 2013 1 1 ## 5 2013 1 1 ## 6 2013 1 1 ## 7 2013 1 1 ## 8 2013 1 1 ## 9 2013 1 1 ## 10 2013 1 1 ## # … with 336,766 more rows # Seleccionar todas las columnas excepto aquellas entre anio en dia (incluyente) dplyr::select(flights, -(year:day)) ## # A tibble: 336,776 x 16 ## dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 517 515 2 830 819 11 UA ## 2 533 529 4 850 830 20 UA ## 3 542 540 2 923 850 33 AA ## 4 544 545 -1 1004 1022 -18 B6 ## 5 554 600 -6 812 837 -25 DL ## 6 554 558 -4 740 728 12 UA ## 7 555 600 -5 913 854 19 B6 ## 8 557 600 -3 709 723 -14 EV ## 9 557 600 -3 838 846 -8 B6 ## 10 558 600 -2 753 745 8 AA ## # … with 336,766 more rows, and 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Hay una serie de funciones auxiliares que puedes usar dentro de select(): starts_with(\"abc\"): coincide con los nombres que comienzan con “abc.” ends_with(\"xyz\"): coincide con los nombres que terminan con “xyz.” contains(\"ijk\"): coincide con los nombres que contienen “ijk.” matches(\"(.)\\\\1\"): selecciona variables que coinciden con una expresión regular (regex). Esta en particular coincide con cualquier variable que contenga caracteres repetidos. num_range(\"x\", 1:3): coincide con x1,x2 y x3. Consulta ?select para ver más detalles. select() se puede usar para cambiar el nombre de las variables, pero rara vez es útil porque descarta todas las variables que no se mencionan explícitamente. En su lugar, utiliza rename(), que es una variante de select() que mantiene todas las variables que no se mencionan explícitamente: names(flights) ## [1] &quot;year&quot; &quot;month&quot; &quot;day&quot; &quot;dep_time&quot; ## [5] &quot;sched_dep_time&quot; &quot;dep_delay&quot; &quot;arr_time&quot; &quot;sched_arr_time&quot; ## [9] &quot;arr_delay&quot; &quot;carrier&quot; &quot;flight&quot; &quot;tailnum&quot; ## [13] &quot;origin&quot; &quot;dest&quot; &quot;air_time&quot; &quot;distance&quot; ## [17] &quot;hour&quot; &quot;minute&quot; &quot;time_hour&quot; # new name = old name df &lt;- rename(flights, tail_num = tailnum) names(df) ## [1] &quot;year&quot; &quot;month&quot; &quot;day&quot; &quot;dep_time&quot; ## [5] &quot;sched_dep_time&quot; &quot;dep_delay&quot; &quot;arr_time&quot; &quot;sched_arr_time&quot; ## [9] &quot;arr_delay&quot; &quot;carrier&quot; &quot;flight&quot; &quot;tail_num&quot; ## [13] &quot;origin&quot; &quot;dest&quot; &quot;air_time&quot; &quot;distance&quot; ## [17] &quot;hour&quot; &quot;minute&quot; &quot;time_hour&quot; Otra opción es usar select() junto con el auxiliar everything() (todo, en inglés). Esto es útil si tienes un grupo de variables que te gustaría mover al comienzo del data frame. dplyr::select(flights, time_hour, air_time, everything()) ## # A tibble: 336,776 x 19 ## time_hour air_time year month day dep_time sched_dep_time ## &lt;dttm&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013-01-01 05:00:00 227 2013 1 1 517 515 ## 2 2013-01-01 05:00:00 227 2013 1 1 533 529 ## 3 2013-01-01 05:00:00 160 2013 1 1 542 540 ## 4 2013-01-01 05:00:00 183 2013 1 1 544 545 ## 5 2013-01-01 06:00:00 116 2013 1 1 554 600 ## 6 2013-01-01 05:00:00 150 2013 1 1 554 558 ## 7 2013-01-01 06:00:00 158 2013 1 1 555 600 ## 8 2013-01-01 06:00:00 53 2013 1 1 557 600 ## 9 2013-01-01 06:00:00 140 2013 1 1 557 600 ## 10 2013-01-01 06:00:00 138 2013 1 1 558 600 ## # … with 336,766 more rows, and 12 more variables: dep_delay &lt;dbl&gt;, ## # arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt; Ejercicios 1. Haz una lluvia de ideas sobre tantas maneras como sea posible para seleccionar dep_time, dep_delay, arr_time, and arr_delay de flights. 2. ¿Qué sucede si incluyes el nombre de una variable varias veces en una llamada a select()? 3. ¿Qué hace la función any_of()? ¡¿Por qué podría ser útil en conjunto con este vector? vars &lt;- c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;dep_delay&quot;, &quot;arr_delay&quot;) 4. ¿Te sorprende el resultado de ejecutar el siguiente código? ¿Cómo tratan por defecto las funciones auxiliares de select() a las palabras en mayúsculas o en minúsculas? ¿Cómo puedes cambiar ese comportamiento predeterminado? dplyr::select(flights, contains(&quot;TIME&quot;)) 3.7.1.6 Añadir nuevas variables con mutate() Además de seleccionar conjuntos de columnas existentes, a menudo es útil crear nuevas columnas en función de columnas existentes. Ese es el trabajo de mutate() (del inglés mutar o transformar). mutate() siempre agrega nuevas columnas al final de un conjunto de datos, así que comenzaremos creando un conjunto de datos más pequeño para que podamos ver las nuevas variables. Recuerda que cuando usas RStudio, la manera más fácil de ver todas las columnas es View(). flights_sml &lt;- dplyr::select( flights, year:day, ends_with(&quot;delay&quot;), distance, air_time ) mutate( flights_sml, gain = arr_delay - dep_delay, speed = distance / (air_time * 60) ) ## # A tibble: 336,776 x 9 ## year month day dep_delay arr_delay distance air_time gain speed ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 2 11 1400 227 9 0.103 ## 2 2013 1 1 4 20 1416 227 16 0.104 ## 3 2013 1 1 2 33 1089 160 31 0.113 ## 4 2013 1 1 -1 -18 1576 183 -17 0.144 ## 5 2013 1 1 -6 -25 762 116 -19 0.109 ## 6 2013 1 1 -4 12 719 150 16 0.0799 ## 7 2013 1 1 -5 19 1065 158 24 0.112 ## 8 2013 1 1 -3 -14 229 53 -11 0.0720 ## 9 2013 1 1 -3 -8 944 140 -5 0.112 ## 10 2013 1 1 -2 8 733 138 10 0.0885 ## # … with 336,766 more rows Ten en cuenta que puedes hacer referencia a las columnas que acabas de crear: mutate( flights_sml, gain = arr_delay - dep_delay, hours = air_time / 60, gain_per_hour = gain / hours ) ## # A tibble: 336,776 x 10 ## year month day dep_delay arr_delay distance air_time gain hours ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 2 11 1400 227 9 3.78 ## 2 2013 1 1 4 20 1416 227 16 3.78 ## 3 2013 1 1 2 33 1089 160 31 2.67 ## 4 2013 1 1 -1 -18 1576 183 -17 3.05 ## 5 2013 1 1 -6 -25 762 116 -19 1.93 ## 6 2013 1 1 -4 12 719 150 16 2.5 ## 7 2013 1 1 -5 19 1065 158 24 2.63 ## 8 2013 1 1 -3 -14 229 53 -11 0.883 ## 9 2013 1 1 -3 -8 944 140 -5 2.33 ## 10 2013 1 1 -2 8 733 138 10 2.3 ## # … with 336,766 more rows, and 1 more variable: gain_per_hour &lt;dbl&gt; Si solo quieres conservar las nuevas variables, usa transmute(): transmute( flights, gain = arr_delay - dep_delay, hours = air_time / 60, gain_per_hour = gain / hours ) ## # A tibble: 336,776 x 3 ## gain hours gain_per_hour ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 9 3.78 2.38 ## 2 16 3.78 4.23 ## 3 31 2.67 11.6 ## 4 -17 3.05 -5.57 ## 5 -19 1.93 -9.83 ## 6 16 2.5 6.4 ## 7 24 2.63 9.11 ## 8 -11 0.883 -12.5 ## 9 -5 2.33 -2.14 ## 10 10 2.3 4.35 ## # … with 336,766 more rows 3.7.1.6.1 Funciones de creación útiles Hay muchas funciones para crear nuevas variables que puedes usar con mutate(). La propiedad clave es que la función debe ser vectorizada: debe tomar un vector de valores como input, y devolver un vector con el mismo número de valores como output. No hay forma de enumerar todas las posibles funciones que podrías usar, pero aquí hay una selección de funciones que frecuentemente son útiles: Operadores aritméticos: +, -, *, /, ^. Todos están vectorizados usando las llamadas “reglas de reciclaje”. Si un parámetro es más corto que el otro, se extenderá automáticamente para tener la misma longitud. Esto es muy útil cuando uno de los argumentos es un solo número: air_time / 60, hours * 60 + minute, etc. Los operadores aritméticos también son útiles junto con las funciones de agregar que aprenderás más adelante. Por ejemplo, x / sum(x) calcula la proporción de un total, y y - mean(y) calcula la diferencia de la media. Aritmética modular: %/% (división entera) y %% (resto), donde x == y * (x %/% y) + (x %% y). La aritmética modular es una herramienta útil porque te permite dividir enteros en partes. Por ejemplo, en el conjunto de datos de vuelos, puedes calcular hora y minutos de dep_time con: transmute( flights, dep_time, hour = dep_time %/% 100, minute = dep_time %% 100 ) ## # A tibble: 336,776 x 3 ## dep_time hour minute ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 517 5 17 ## 2 533 5 33 ## 3 542 5 42 ## 4 544 5 44 ## 5 554 5 54 ## 6 554 5 54 ## 7 555 5 55 ## 8 557 5 57 ## 9 557 5 57 ## 10 558 5 58 ## # … with 336,766 more rows Logaritmos: log(), log2(), log10(). Los logaritmos son increíblemente útiles como transformación para trabajar con datos con múltiples órdenes de magnitud. También convierten las relaciones multiplicativas en aditivas, una característica que retomaremos en los capítulos sobre modelos. En igualdad de condiciones, recomendamos usar log2() porque es más fácil de interpretar: una diferencia de 1 en la escala de registro corresponde a la duplicación de la escala original y una diferencia de -1 corresponde a dividir a la mitad. Rezagos: lead() y lag() te permiten referirte a un valor adelante o un valor atrás (con rezago). Esto te permite calcular las diferencias móviles (por ejemplo, x - lag(x)) o encontrar cuándo cambian los valores (x! = lag (x)). Estos comandos son más útiles cuando se utilizan junto con group_by(), algo que aprenderás en breve. (x &lt;- 1:10) ## [1] 1 2 3 4 5 6 7 8 9 10 lag(x) ## [1] NA 1 2 3 4 5 6 7 8 9 lead(x) ## [1] 2 3 4 5 6 7 8 9 10 NA Agregados acumulativos y móviles: R proporciona funciones para ejecutar sumas, productos, mínimos y máximos: cumsum(), cumprod(), cummin(), cummax(); dplyr, por su parte, proporciona cummean() para las medias acumuladas. Si necesitas calcular agregados móviles (es decir, una suma calculada en una ventana móvil), prueba el paquete RcppRoll. x ## [1] 1 2 3 4 5 6 7 8 9 10 cumsum(x) ## [1] 1 3 6 10 15 21 28 36 45 55 cummean(x) ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 Comparaciones lógicas: &lt;, &lt;=, &gt;, &gt;=, != sobre las cuales aprendiste antes. Si estás haciendo una secuencia compleja de operaciones lógicas, es a menudo una buena idea almacenar los valores provisionales en nuevas variables para que puedas comprobar que cada paso funciona como se espera. Ordenamiento: hay una serie de funciones de ordenamiento (ranking), pero deberías comenzar con min_rank(). Esta función realiza el tipo más común de ordenamiento (por ejemplo, primero, segundo, tercero, etc.). El valor predeterminado otorga la menor posición a los valores más pequeños; usa desc(x) para dar la menor posición a los valores más grandes. y &lt;- c (1, 2, 2, NA, 3, 4) min_rank(y) ## [1] 1 2 2 NA 4 5 min_rank(desc(y)) ## [1] 5 3 3 NA 2 1 Si min_rank() no hace lo que necesitas, consulta las variantes row_number(), dense_rank(), percent_rank(), cume_dist(), quantile(). Revisa sus páginas de ayuda para más detalles. row_number(y) ## [1] 1 2 3 NA 4 5 dense_rank(y) ## [1] 1 2 2 NA 3 4 percent_rank(y) ## [1] 0.00 0.25 0.25 NA 0.75 1.00 cume_dist(y) ## [1] 0.2 0.6 0.6 NA 0.8 1.0 Ejercicios 1. Las variables horario_salida y salida_programada tienen un formato conveniente para leer, pero es difícil realizar cualquier cálculo con ellas porque no son realmente números continuos. Transfórmalas hacia un formato más conveniente como número de minutos desde la medianoche. 2. Compara tiempo_vuelo con horario_llegada - horario_salida. ¿Qué esperas ver? ¿Qué ves? ¿Qué necesitas hacer para arreglarlo? 3. Compara horario_salida, salida_programada, y atraso_salida. ¿Cómo esperarías que esos tres números estén relacionados? 4. Encuentra los 10 vuelos más retrasados utilizando una función de ordenamiento. ¿Cómo quieres manejar los empates? Lee atentamente la documentación de min_rank(). 5. ¿Qué devuelve 1:3 + 1:10? ¿Por qué? 6. ¿Qué funciones trigonométricas proporciona R? 3.7.1.6.2 Resúmenes agrupados con summarise() El último verbo clave es summarise() (resumir, en inglés). Se encarga de colapsar un data frame en una sola fila: summarize(flights, delay = mean(dep_delay, na.rm = TRUE)) ## # A tibble: 1 x 1 ## delay ## &lt;dbl&gt; ## 1 12.6 summarise() no es muy útil a menos que lo enlacemos con group_by(). Esto cambia la unidad de análisis del conjunto de datos completo a grupos individuales. Luego, cuando uses los verbos dplyr en un data frame agrupado, estos se aplicarán automáticamente “por grupo”. Por ejemplo, si aplicamos exactamente el mismo código a un dataframe agrupado por fecha, obtenemos el retraso promedio por fecha: by_day &lt;- group_by(flights, year, month, day) summarize(by_day, delay = mean(dep_delay, na.rm = TRUE)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 x 4 ## # Groups: year, month [12] ## year month day delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 11.5 ## 2 2013 1 2 13.9 ## 3 2013 1 3 11.0 ## 4 2013 1 4 8.95 ## 5 2013 1 5 5.73 ## 6 2013 1 6 7.15 ## 7 2013 1 7 5.42 ## 8 2013 1 8 2.55 ## 9 2013 1 9 2.28 ## 10 2013 1 10 2.84 ## # … with 355 more rows Juntos group_by() y summarise() proporcionan una de las herramientas que más comúnmente usarás cuando trabajes con dplyr: resúmenes agrupados. Pero antes de ir más allá con esto, tenemos que introducir una idea nueva y poderosa: el pipe (pronunciado /paip/, que en inglés significa ducto o tubería). 3.7.1.6.2.1 Combinación de múltiples operaciones con el pipe Imagina que queremos explorar la relación entre la distancia y el atraso promedio para cada ubicación. Usando lo que sabes acerca de dplyr, podrías escribir un código como este: by_dest &lt;- group_by(flights, dest) delay &lt;- summarize( by_dest, count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE) ) # Parece que las demoras aumentan con las distancias hasta ~ 750 millas # y luego disminuyen. ¿Tal vez a medida que los vuelos se hacen más # largos, hay más habilidad para compensar las demoras en el aire? ggplot(data = delay, mapping = aes(x = dist, y = delay)) + geom_point(aes(size = count), alpha = 1/3) + geom_smooth(se = FALSE) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Hay tres pasos para preparar esta información: Agrupar los vuelos por destino. Resumir para calcular la distancia, la demora promedio y el número de vuelos en cada grupo. Filtrar para eliminar puntos ruidosos y el aeropuerto de Honolulu, que está casi dos veces más lejos que el próximo aeropuerto más cercano. Es un poco frustrante escribir este código porque tenemos que dar un nombre a cada data frame intermedio, incluso si el dataframe en sí mismo no nos importa. Nombrar cosas es difícil y dilata el tiempo de nuestro análisis. Hay otra forma de abordar el mismo problema con el pipe, %&gt;%: delays &lt;- flights %&gt;% group_by(dest) %&gt;% summarise( count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE) ) %&gt;% filter(count &gt; 20, dest != &quot;HNL&quot;) Este código se enfoca en las transformaciones, no en lo que se está transformando, lo que hace que sea más fácil de leer. Puedes leerlo como una serie de declaraciones imperativas: agrupa, luego resume y luego filtra. Como sugiere esta lectura, una buena forma de pronunciar %&gt;% cuando se lee el código es “luego”. Lo que ocurre detrás del código, es que x %&gt;% f(y) se convierte en f(x, y), y x %&gt;% f(y) %&gt;% g(z) se convierte en g(f(x, y), z) y así sucesivamente. Puedes usar el pipe para reescribir múltiples operaciones de forma que puedas leer de izquierda a derecha, de arriba hacia abajo. Usaremos pipes con frecuencia a partir de ahora porque mejora considerablemente la legibilidad del código. Volveremos a este tema con más detalles en pipes. Trabajar con el pipe es uno de los criterios clave para pertenecer al tidyverse. La única excepción es ggplot2: se escribió antes de que se descubriera el pipe. Lamentablemente, la siguiente iteración de ggplot2, ggvis, que sí utiliza el pipe, aún no está lista para el horario estelar. 3.7.1.6.2.2 Valores faltantes Es posible que te hayas preguntado sobre el argumento na.rm que utilizamos anteriormente. ¿Qué pasa si no lo configuramos? flights %&gt;% group_by(year, month, day) %&gt;% summarise(mean = mean(dep_delay)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 x 4 ## # Groups: year, month [12] ## year month day mean ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 NA ## 2 2013 1 2 NA ## 3 2013 1 3 NA ## 4 2013 1 4 NA ## 5 2013 1 5 NA ## 6 2013 1 6 NA ## 7 2013 1 7 NA ## 8 2013 1 8 NA ## 9 2013 1 9 NA ## 10 2013 1 10 NA ## # … with 355 more rows ¡Obtenemos muchos valores faltantes! Esto se debe a que las funciones de agregación obedecen la regla habitual de valores faltantes: si hay uno en el input, el output también será un valor faltante. Afortunadamente, todas las funciones de agregación tienen un argumento na.rm que elimina los valores faltantes antes del cálculo: flights %&gt;% group_by(year, month, day) %&gt;% summarise(mean = mean(dep_delay, na.rm = TRUE)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 x 4 ## # Groups: year, month [12] ## year month day mean ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 11.5 ## 2 2013 1 2 13.9 ## 3 2013 1 3 11.0 ## 4 2013 1 4 8.95 ## 5 2013 1 5 5.73 ## 6 2013 1 6 7.15 ## 7 2013 1 7 5.42 ## 8 2013 1 8 2.55 ## 9 2013 1 9 2.28 ## 10 2013 1 10 2.84 ## # … with 355 more rows En este caso, en el que los valores faltantes representan vuelos cancelados, también podríamos abordar el problema eliminando primero este tipo de vuelos. Guardaremos este conjunto de datos para poder reutilizarlo en los siguientes ejemplos. not_cancelled &lt;- flights %&gt;% filter(!is.na(dep_delay), !is.na(arr_delay)) not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarise(mean = mean(dep_delay)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 x 4 ## # Groups: year, month [12] ## year month day mean ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 11.4 ## 2 2013 1 2 13.7 ## 3 2013 1 3 10.9 ## 4 2013 1 4 8.97 ## 5 2013 1 5 5.73 ## 6 2013 1 6 7.15 ## 7 2013 1 7 5.42 ## 8 2013 1 8 2.56 ## 9 2013 1 9 2.30 ## 10 2013 1 10 2.84 ## # … with 355 more rows 3.7.1.6.2.3 Conteos Siempre que realices una agregación, es una buena idea incluir un conteo (n()) o un recuento de valores no faltantes (sum(!is.na(x))). De esta forma, puedes verificar que no estás sacando conclusiones basadas en cantidades muy pequeñas de datos. Por ejemplo, veamos los aviones (identificados por su número de cola) que tienen las demoras promedio más altas: delays &lt;- not_cancelled %&gt;% group_by(tailnum) %&gt;% summarise( delay = mean(arr_delay) ) ggplot(data = delays, mapping = aes(x = delay)) + geom_freqpoly(binwidth = 10) + theme_bw() ¡Hay algunos aviones que tienen una demora promedio de 5 horas (300 minutos)! La historia es en realidad un poco más matizada. Podemos obtener más información si hacemos un diagrama de dispersión del número de vuelos contra la demora promedio: delays &lt;- not_cancelled %&gt;% group_by(tailnum) %&gt;% summarise( delay = mean(arr_delay, na.rm = TRUE), n = n() ) ggplot(data = delays, mapping = aes(x = n, y = delay)) + geom_point(alpha = 1/10) + theme_bw() No es sorprendente que haya una mayor variación en el promedio de retraso cuando hay pocos vuelos. La forma de este gráfico es muy característica: cuando trazas un promedio (o cualquier otra medida de resumen) contra el tamaño del grupo, verás que la variación decrece a medida que el tamaño de muestra aumenta. Cuando se observa este tipo de gráficos, resulta útil eliminar los grupos con menor número de observaciones, ya que puedes ver más del patrón y menos de la variación extrema de los grupos pequeños. Esto es lo que hace el siguiente bloque de código. También te ofrece una manera muy útil para integrar ggplot2 en el flujo de trabajo de dplyr. Es un poco incómodo tener que cambiar de %&gt;% a +, pero una vez que entiendas el código, verás que es bastante conveniente. delays %&gt;% filter(n &gt; 25) %&gt;% ggplot(mapping = aes(x = n, y = delay)) + geom_point(alpha = 1/10) + theme_bw() Hay otra variación común de este tipo de patrón. Veamos cómo el rendimiento promedio de los bateadores en el béisbol está relacionado con el número de veces que les toca batear. Aquí utilizaremos el conjunto de datos de bateadores para calcular el promedio de bateo (número de bateos / número de intentos) de cada jugador de béisbol de las Grandes Ligas. Cuando graficamos la habilidad del bateador (medido por el promedio de bateo, pb) contra el número de oportunidades para golpear la pelota (medido por el tiempo al bate,ab), verás dos patrones: Como en el ejemplo anterior, la variación en nuestro estadístico de resumen disminuye a medida que obtenemos más observaciones. Existe una correlación positiva entre la habilidad (pb) y las oportunidades para golpear la pelota (ab). Esto se debe a que los equipos controlan quién puede jugar y, obviamente, elegirán a sus mejores jugadores. # Convert to a tibble so it prints nicely bateo &lt;- as_tibble(datos::bateadores) rendimiento_bateadores &lt;- bateo %&gt;% group_by(id_jugador) %&gt;% summarise( pb = sum(golpes, na.rm = TRUE) / sum(al_bate, na.rm = TRUE), ab = sum(al_bate, na.rm = TRUE) ) rendimiento_bateadores %&gt;% filter(ab &gt; 100) %&gt;% ggplot(mapping = aes(x = ab, y = pb)) + geom_point() + geom_smooth(se = FALSE) + theme_bw() ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; Esto también tiene implicaciones importantes para la clasificación. Si ingenuamente ordenas desc(pb), verás que las personas con los mejores promedios de bateo tienen claramente mucha suerte, pero no son necesariamente hábiles: Puedes encontrar una buena explicación de este problema en http://varianceexplained.org/r/empirical_bayes_baseball/ y http://www.evanmiller.org/how-not-to-sort-by-average-rating.html. 3.7.1.6.2.4 Funciones de resumen útiles Solo el uso de medias, conteos y sumas puede llevarte muy lejos, pero R proporciona muchas otras funciones de resumen útiles: Medidas de posición: first(x), nth(x, 2), last(x). Estas trabajan de forma similar a x[1], x[2] y x[length (x)], pero te permiten establecer un valor predeterminado en el caso de que esa posición no exista (es decir, si estás tratando de obtener el tercer elemento de un grupo que solo tiene dos elementos). Por ejemplo, podemos encontrar la primera (first) y última (last) salida para cada día: not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarise( first_dep = first(dep_time), last_dep = last(dep_time) ) ## # A tibble: 365 x 5 ## # Groups: year, month [12] ## year month day first_dep last_dep ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 2356 ## 2 2013 1 2 42 2354 ## 3 2013 1 3 32 2349 ## 4 2013 1 4 25 2358 ## 5 2013 1 5 14 2357 ## 6 2013 1 6 16 2355 ## 7 2013 1 7 49 2359 ## 8 2013 1 8 454 2351 ## 9 2013 1 9 2 2252 ## 10 2013 1 10 3 2320 ## # … with 355 more rows Medidas de centralidad: hemos usado mean(x), pero median(x) también resulta muy útil. La media es la suma dividida por el número de observaciones; la mediana es un valor donde el 50% de x está por encima de él y el 50% está por debajo. A veces es útil combinar agregación con un subconjunto lógico. not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarise( avg_delay1 = mean(arr_delay), avg_delay2 = mean(arr_delay[arr_delay &gt; 0]) # the average positive delay ) ## # A tibble: 365 x 5 ## # Groups: year, month [12] ## year month day avg_delay1 avg_delay2 ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 12.7 32.5 ## 2 2013 1 2 12.7 32.0 ## 3 2013 1 3 5.73 27.7 ## 4 2013 1 4 -1.93 28.3 ## 5 2013 1 5 -1.53 22.6 ## 6 2013 1 6 4.24 24.4 ## 7 2013 1 7 -4.95 27.8 ## 8 2013 1 8 -3.23 20.8 ## 9 2013 1 9 -0.264 25.6 ## 10 2013 1 10 -5.90 27.3 ## # … with 355 more rows Medidas de rango: min(x), quantile(x, 0.25), max(x). Los cuantiles son una generalización de la mediana. Por ejemplo, quantile(x, 0.25) encontrará un valor de x que sea mayor a 25% de los valores, y menor que el 75% restante. not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarise( first = min(dep_time), last = max(dep_time) ) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 x 5 ## # Groups: year, month [12] ## year month day first last ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 2356 ## 2 2013 1 2 42 2354 ## 3 2013 1 3 32 2349 ## 4 2013 1 4 25 2358 ## 5 2013 1 5 14 2357 ## 6 2013 1 6 16 2355 ## 7 2013 1 7 49 2359 ## 8 2013 1 8 454 2351 ## 9 2013 1 9 2 2252 ## 10 2013 1 10 3 2320 ## # … with 355 more rows Medidas de dispersión: sd(x), IQR(x), mad(x). La raíz cuadrad de la varianza o desviación estándar sd(x) es una medida estándar de dispersión. El rango intercuartil IQR() y la desviación media absoluta mad(x) son medidas robustas equivalentes que pueden ser más útiles si tienes valores atípicos. not_cancelled %&gt;% group_by(dest) %&gt;% summarise(distance_sd = sd(distance)) %&gt;% arrange(desc(distance_sd)) ## # A tibble: 104 x 2 ## dest distance_sd ## &lt;chr&gt; &lt;dbl&gt; ## 1 EGE 10.5 ## 2 SAN 10.4 ## 3 SFO 10.2 ## 4 HNL 10.0 ## 5 SEA 9.98 ## 6 LAS 9.91 ## 7 PDX 9.87 ## 8 PHX 9.86 ## 9 LAX 9.66 ## 10 IND 9.46 ## # … with 94 more rows Estas funciones son complementarias al filtrado en rangos. El filtrado te proporciona todas las variables, con cada observación en una fila distinta: not_cancelled %&gt;% group_by(year, month, day) %&gt;% mutate(r = min_rank(desc(dep_time))) %&gt;% filter(r %in% range(r)) %&gt;% dplyr::select(r) ## Adding missing grouping variables: `year`, `month`, `day` ## # A tibble: 770 x 4 ## # Groups: year, month, day [365] ## year month day r ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 831 ## 2 2013 1 1 1 ## 3 2013 1 2 928 ## 4 2013 1 2 1 ## 5 2013 1 3 900 ## 6 2013 1 3 1 ## 7 2013 1 4 908 ## 8 2013 1 4 1 ## 9 2013 1 4 1 ## 10 2013 1 5 717 ## # … with 760 more rows Conteos: has visto n(), que no toma argumentos y que devuelve el tamaño del grupo actual. Para contar la cantidad de valores no faltantes, usa sum(!is.na (x)). Para contar la cantidad de valores distintos (únicos), usa n_distinct(x). # ¿Qué destinos tienen la mayoría de las aerolíneas? not_cancelled %&gt;% group_by(dest) %&gt;% summarise(carriers = n_distinct(carrier)) %&gt;% arrange(desc(carriers)) ## # A tibble: 104 x 2 ## dest carriers ## &lt;chr&gt; &lt;int&gt; ## 1 ATL 7 ## 2 BOS 7 ## 3 CLT 7 ## 4 ORD 7 ## 5 TPA 7 ## 6 AUS 6 ## 7 DCA 6 ## 8 DTW 6 ## 9 IAD 6 ## 10 MSP 6 ## # … with 94 more rows Los conteos son tan útiles que dplyr proporciona un ayudante simple si todo lo que quieres es un conteo: not_cancelled %&gt;% count(dest) ## # A tibble: 104 x 2 ## dest n ## &lt;chr&gt; &lt;int&gt; ## 1 ABQ 254 ## 2 ACK 264 ## 3 ALB 418 ## 4 ANC 8 ## 5 ATL 16837 ## 6 AUS 2411 ## 7 AVL 261 ## 8 BDL 412 ## 9 BGR 358 ## 10 BHM 269 ## # … with 94 more rows Opcionalmente puedes proporcionar una variable de ponderación. Por ejemplo, podrías usar esto para “contar” (sumar) el número total de millas que voló un avión: not_cancelled %&gt;% count(tailnum, wt = distance) ## # A tibble: 4,037 x 2 ## tailnum n ## &lt;chr&gt; &lt;dbl&gt; ## 1 D942DN 3418 ## 2 N0EGMQ 239143 ## 3 N10156 109664 ## 4 N102UW 25722 ## 5 N103US 24619 ## 6 N104UW 24616 ## 7 N10575 139903 ## 8 N105UW 23618 ## 9 N107US 21677 ## 10 N108UW 32070 ## # … with 4,027 more rows Conteos y proporciones de valores lógicos: sum(x &gt; 10), mean(y == 0). Cuando se usan con funciones numéricas, TRUE se convierte en 1 y FALSE en 0. Esto hace que sum() y mean() sean muy útiles: sum(x) te da la cantidad de TRUE en x, y mean(x) te da la proporción. # ¿Cuántos vuelos salieron antes de las 5 am? # (estos generalmente son vuelos demorados del día anterior) not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarise(n_early = sum(dep_time &lt; 500)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 x 4 ## # Groups: year, month [12] ## year month day n_early ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 0 ## 2 2013 1 2 3 ## 3 2013 1 3 4 ## 4 2013 1 4 3 ## 5 2013 1 5 3 ## 6 2013 1 6 2 ## 7 2013 1 7 2 ## 8 2013 1 8 1 ## 9 2013 1 9 3 ## 10 2013 1 10 3 ## # … with 355 more rows # ¿Qué proporción de vuelos se retrasan más de una hora? not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarise(hour_prop = mean(arr_delay &gt; 60)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 x 4 ## # Groups: year, month [12] ## year month day hour_prop ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 0.0722 ## 2 2013 1 2 0.0851 ## 3 2013 1 3 0.0567 ## 4 2013 1 4 0.0396 ## 5 2013 1 5 0.0349 ## 6 2013 1 6 0.0470 ## 7 2013 1 7 0.0333 ## 8 2013 1 8 0.0213 ## 9 2013 1 9 0.0202 ## 10 2013 1 10 0.0183 ## # … with 355 more rows 3.7.1.6.3 Agrupación por múltiples variables Cuando agrupas por múltiples variables, cada resumen se desprende de un nivel de la agrupación. Eso hace que sea más fácil acumular progresivamente en un conjunto de datos: daily &lt;- group_by(flights, year, month, day) (per_day &lt;- summarise(daily, flights = n())) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 x 4 ## # Groups: year, month [12] ## year month day flights ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 842 ## 2 2013 1 2 943 ## 3 2013 1 3 914 ## 4 2013 1 4 915 ## 5 2013 1 5 720 ## 6 2013 1 6 832 ## 7 2013 1 7 933 ## 8 2013 1 8 899 ## 9 2013 1 9 902 ## 10 2013 1 10 932 ## # … with 355 more rows (per_month &lt;- summarise(per_day, flights = sum(flights))) ## `summarise()` has grouped output by &#39;year&#39;. You can override using the `.groups` argument. ## # A tibble: 12 x 3 ## # Groups: year [1] ## year month flights ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 27004 ## 2 2013 2 24951 ## 3 2013 3 28834 ## 4 2013 4 28330 ## 5 2013 5 28796 ## 6 2013 6 28243 ## 7 2013 7 29425 ## 8 2013 8 29327 ## 9 2013 9 27574 ## 10 2013 10 28889 ## 11 2013 11 27268 ## 12 2013 12 28135 (per_year &lt;- summarise(per_month, flights = sum(flights))) ## # A tibble: 1 x 2 ## year flights ## &lt;int&gt; &lt;int&gt; ## 1 2013 336776 Ten cuidado al acumular resúmenes progresivamente: está bien para las sumas y los recuentos, pero debes pensar en la ponderación de las medias y las varianzas, además de que no es posible hacerlo exactamente para estadísticas basadas en rangos como la mediana. En otras palabras, la suma de las sumas agrupadas es la suma total, pero la mediana de las medianas agrupadas no es la mediana general. 3.7.1.6.4 Desagrupar Si necesitas eliminar la agrupación y regresar a las operaciones en datos desagrupados, usa ungroup(). daily %&gt;% ungroup() %&gt;% # no longer grouped by date summarise(flights = n()) # all flights ## # A tibble: 1 x 1 ## flights ## &lt;int&gt; ## 1 336776 Ejercicios 1. Haz una lluvia de ideas de al menos 5 formas diferentes de evaluar las características de un retraso típico de un grupo de vuelos. Considera los siguientes escenarios: - Un vuelo llega 15 minutos antes 50% del tiempo, y 15 minutos tarde 50% del tiempo. - Un vuelo llega siempre 10 minutos tarde. - Un vuelo llega 30 minutos antes 50% del tiempo, y 30 minutos tarde 50% del tiempo. - Un vuelo llega a tiempo en el 99% de los casos. 1% de las veces llega 2 horas tarde. ¿Qué es más importante: retraso de la llegada o demora de salida? 2. Sugiere un nuevo enfoque que te dé el mismo output que no_cancelados %&gt;% count(destino) y no_cancelado %&gt;% count(codigo_cola, wt = distancia) (sin usar count()). 3. Nuestra definición de vuelos cancelados (is.na(atraso_salida) | is.na (atraso_llegada)) es un poco subóptima. ¿Por qué? ¿Cuál es la columna más importante? 4. Mira la cantidad de vuelos cancelados por día. ¿Hay un patrón? ¿La proporción de vuelos cancelados está relacionada con el retraso promedio? 5. ¿Qué compañía tiene los peores retrasos? Desafío: ¿puedes desenredar el efecto de malos aeropuertos vs. el efecto de malas aerolíneas? ¿Por qué o por qué no? (Sugerencia: piensa en vuelos %&gt;% group_by(aerolinea, destino) %&gt;% summarise(n())) 6. ¿Qué hace el argumento sort a count(). ¿Cuándo podrías usarlo? 3.7.1.6.5 Transformaciones agrupadas (y filtros) La agrupación es más útil si se utiliza junto con summarise(), pero también puedes hacer operaciones convenientes con mutate() y filter(): Encuentra los peores miembros de cada grupo: flights_sml %&gt;% group_by(year, month, day) %&gt;% filter(rank(desc(arr_delay)) &lt; 10) ## # A tibble: 3,306 x 7 ## # Groups: year, month, day [365] ## year month day dep_delay arr_delay distance air_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 853 851 184 41 ## 2 2013 1 1 290 338 1134 213 ## 3 2013 1 1 260 263 266 46 ## 4 2013 1 1 157 174 213 60 ## 5 2013 1 1 216 222 708 121 ## 6 2013 1 1 255 250 589 115 ## 7 2013 1 1 285 246 1085 146 ## 8 2013 1 1 192 191 199 44 ## 9 2013 1 1 379 456 1092 222 ## 10 2013 1 2 224 207 550 94 ## # … with 3,296 more rows Encuentra todos los grupos más grandes que un determinado umbral: popular_dests &lt;- flights %&gt;% group_by(dest) %&gt;% filter(n() &gt; 365) popular_dests ## # A tibble: 332,577 x 19 ## # Groups: dest [77] ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 332,567 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Estandariza para calcular las métricas por grupo: popular_dests %&gt;% filter(arr_delay &gt; 0) %&gt;% mutate(prop_delay = arr_delay / sum(arr_delay)) %&gt;% select(year:day, dest, arr_delay, prop_delay) ## # A tibble: 131,106 x 6 ## # Groups: dest [77] ## year month day dest arr_delay prop_delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 IAH 11 0.000111 ## 2 2013 1 1 IAH 20 0.000201 ## 3 2013 1 1 MIA 33 0.000235 ## 4 2013 1 1 ORD 12 0.0000424 ## 5 2013 1 1 FLL 19 0.0000938 ## 6 2013 1 1 ORD 8 0.0000283 ## 7 2013 1 1 LAX 7 0.0000344 ## 8 2013 1 1 DFW 31 0.000282 ## 9 2013 1 1 ATL 12 0.0000400 ## 10 2013 1 1 DTW 16 0.000116 ## # … with 131,096 more rows Un filtro agrupado es una transformación agrupada seguida de un filtro desagrupado. En general, preferimos evitarlos, excepto para las manipulaciones rápidas y sucias: de lo contrario, es difícil comprobar que has hecho la manipulación correctamente. Las funciones que trabajan de forma más natural en transformaciones agrupadas y filtros se conocen como funciones de ventana o window functions (frente a las funciones de resumen utilizadas para los resúmenes). Puedes obtener más información sobre las funciones de ventana útiles en la viñeta correspondiente: vignette(\"window-functions\"). Ejercicios 1. Remítete a las listas de funciones útiles de mutación y filtrado. Describe cómo cambia cada operación cuando las combinas con la agrupación. 2. ¿Qué avión (codigo_cola) tiene el peor registro de tiempo? 3. ¿A qué hora del día deberías volar si quieres evitar lo más posible los retrasos? 4. Para cada destino, calcula los minutos totales de demora. Para cada vuelo, calcula la proporción de la demora total para su destino. 5. Los retrasos suelen estar temporalmente correlacionados: incluso una vez que el problema que causó el retraso inicial se ha resuelto, los vuelos posteriores se retrasan para permitir que salgan los vuelos anteriores. Usando lag(), explora cómo el retraso de un vuelo está relacionado con el retraso del vuelo inmediatamente anterior. 6. Mira cada destino. ¿Puedes encontrar vuelos sospechosamente rápidos? (es decir, vuelos que representan un posible error de entrada de datos). Calcula el tiempo en el aire de un vuelo relativo al vuelo más corto a ese destino. ¿Cuáles vuelos se retrasaron más en el aire? 7. Encuentra todos los destinos que son volados por al menos dos operadores. Usa esta información para clasificar a las aerolíneas. 8. Para cada avión, cuenta el número de vuelos antes del primer retraso de más de 1 hora. 3.8 Gráficos con ggplot 3.8.1 Introducción “Un simple gráfico ha brindado más información a la mente del analista de datos que cualquier otro dispositivo.” — John Tukey En este capítulo aprenderás cómo visualizar tus datos usando el paquete ggplot2. De los muchos sistemas que posee R para hacer gráficos, ggplot2 es uno de los más elegantes y versátiles. Esto se debe a que ggplot2 implementa un sistema coherente para describir y construir gráficos, conocido como la gramática de gráficos. Con ggplot2 puedes hacer más cosas en menor tiempo, aprendiendo un único sistema y aplicándolo en diferentes ámbitos. Si deseas obtener más información sobre los fundamentos teóricos de ggplot2 antes de comenzar, te recomendamos leer “La gramática de gráficos en capas,” http://vita.had.co.nz/papers/layered-grammar.pdf. 3.8.1.1 Prerrequisitos Este capítulo se centra en ggplot2, uno de los paquetes principales del Tidyverse. Para acceder a sus funciones y las páginas de ayuda que utilizaremos en este capítulo, debes cargar el Tidyverse ejecutando este código: library(tidyverse) Esa única línea de código carga el núcleo del Tidyverse, que está compuesto por los paquetes que usarás en casi todos tus análisis de datos. Al correr esta línea también verás cuáles funciones de tidyverse pueden tener conflicto con funciones de R base (o de otros paquetes que puedas haber cargado previamente). Si ejecutas este código y recibes el mensaje “Error in library(tidyverse): there is no package called ‘tidyverse’” (no hay ningún paquete llamado ‘tidyverse’), primero deberás instalarlo y luego ejecutar library(): install.packages(&quot;tidyverse&quot;) library(tidyverse) Solo es necesario que instales los paquetes una única vez; sin embargo, tendrás que cargarlos siempre que inicies una nueva sesión. Cuando necesitemos especificar la procedencia de una función (o un conjunto de datos), usaremos el formato especial paquete::funcion(). Por ejemplo, ggplot2::ggplot() dice explícitamente que estamos usando la función ggplot() del paquete ggplot2. Además del Tidyverse, es necesario que cargues el paquete datos, ya que en él están contenidas las versiones en español de los datos que utilizaremos en este capítulo: # install.packages(&quot;datos&quot;) library(datos) ## ## Attaching package: &#39;datos&#39; ## The following object is masked _by_ &#39;.GlobalEnv&#39;: ## ## frutas 3.8.2 Primeros pasos Usemos nuestro primer gráfico para responder una pregunta: ¿los automóviles con motores grandes consumen más combustible que los automóviles con motores pequeños? Probablemente ya tengas una respuesta, pero trata de responder de forma precisa. ¿Cómo es la relación entre el tamaño del motor y la eficiencia del combustible? ¿Es positiva? ¿Es negativa? ¿Es lineal o no lineal? 3.8.2.1 El data frame millas Puedes poner a prueba tu respuesta empleando el data frame millas que se encuentra en el paquete datos (datos::millas). Un data frame es una colección rectangular de variables (columnas) y observaciones (filas). El data frame millas contiene observaciones para 38 modelos de automóviles recopiladas por la Agencia de Protección Ambiental de los EE. UU. millas ## # A tibble: 234 x 11 ## fabricante modelo cilindrada anio cilindros transmision traccion ciudad ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 audi a4 1.8 1999 4 auto(l5) d 18 ## 2 audi a4 1.8 1999 4 manual(m5) d 21 ## 3 audi a4 2 2008 4 manual(m6) d 20 ## 4 audi a4 2 2008 4 auto(av) d 21 ## 5 audi a4 2.8 1999 6 auto(l5) d 16 ## 6 audi a4 2.8 1999 6 manual(m5) d 18 ## 7 audi a4 3.1 2008 6 auto(av) d 18 ## 8 audi a4 quattro 1.8 1999 4 manual(m5) 4 18 ## 9 audi a4 quattro 1.8 1999 4 auto(l5) 4 16 ## 10 audi a4 quattro 2 2008 4 manual(m6) 4 20 ## # … with 224 more rows, and 3 more variables: autopista &lt;int&gt;, ## # combustible &lt;chr&gt;, clase &lt;chr&gt; Entre las variables de millas se encuentran: cilindrada: tamaño del motor del automóvil, en litros. autopista: eficiencia del uso de combustible de un automóvil en carretera, en millas por galón. Al recorrer la misma distancia, un automóvil de baja eficiencia consume más combustible que un automóvil de alta eficiencia. Para obtener más información sobre el data frame millas, abre su página de ayuda ejecutando ?millas. 3.8.2.2 Creando un gráfico con ggplot Para graficar millas, ejecuta este código para poner cilindrada en el eje x y autopista en el eje y: ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista)) El gráfico muestra una relación negativa entre el tamaño del motor (cilindrada) y la eficiencia del combustible (autopista). En otras palabras, los vehículos con motores grandes usan más combustible. Este resultado, ¿confirma o refuta tu hipótesis acerca de la relación entre la eficiencia del combustible y el tamaño del motor? Para comenzar un gráfico con ggplot2 se utiliza la función ggplot(). ggplot() crea un sistema de coordenadas al que puedes agregar capas. El primer argumento de ggplot() es el conjunto de datos que se utilizará en el gráfico. Si corres ggplot(data = millas), obtendrás un gráfico vacío. Como no es muy interesante, no vamos a mostrarlo aquí. Para completar tu gráfico debes agregar una o más capas a ggplot(). La función geom_point() agrega una capa de puntos al gráfico, lo que crea un diagrama de dispersión (o scatterplot). ggplot2 incluye muchas funciones geom, cada una de las cuales agrega un tipo de capa diferente a un gráfico. Aprenderás muchas de ellas a lo largo de este capítulo. Cada función geom en ggplot2 tiene un argumento de mapping. Este define cómo se “mapean” o se asignan las variables del conjunto de datos a propiedades visuales. El argumento de mapping siempre aparece emparejado con aes() y los argumentos x e y dentro de aes() especifican qué variables asignar a estos ejes. ggplot2 busca la variable asignada en el argumento data, en este caso, millas. 3.8.2.3 Una plantilla de gráficos Convirtamos ahora este código en una plantilla reutilizable para hacer gráficos con ggplot2. Para hacer un gráfico, reemplaza las secciones entre corchetes en el siguiente código con un conjunto de datos, una función geom o una colección de mapeos. ggplot(data = &lt;DATOS&gt;) + &lt;GEOM_FUNCIÓN&gt;(mapping = aes(&lt;MAPEOS&gt;)) El resto de este capítulo te mostrará cómo utilizar y adaptar esta plantilla para crear diferentes tipos de gráficos. Comenzaremos por el componente &lt;MAPEOS&gt; Ejercicios - Ejecuta ggplot(data = millas). ¿Qué observas? - ¿Cuántas filas hay en millas? ¿Cuántas columnas? - ¿Qué describe la variable traccion? Lee la ayuda de ?millas para encontrar la respuesta. - Realiza un gráfico de dispersión de autopista versus cilindros. - ¿Qué sucede cuando haces un gráfico de dispersión (scatterplot) de clase versus traccion? ¿Por qué no es útil este gráfico? 3.8.3 Mapeos estéticos “El mayor valor de una imagen es cuando nos obliga a observar lo que no esperábamos ver.” — John Tukey En el siguiente gráfico, un grupo de puntos (resaltados en rojo) parece quedar fuera de la tendencia lineal. Estos automóviles tienen un kilometraje mayor de lo que esperaríamos. ¿Cómo puedes explicar estos vehículos? Supongamos que estos automóviles son híbridos. Una forma de probar esta hipótesis es observando la variable que indica la clase de cada automóvil. La variable clase del conjunto de datos de millas clasifica los autos en grupos como compacto, mediano y SUV. Si los puntos periféricos corresponden a automóviles híbridos, deberían estar clasificados como compactos o, tal vez, subcompactos (ten en cuenta que estos datos se recopilaron antes de que las camionetas híbridas y SUV se hicieran populares). Puedes agregar una tercera variable, como clase, a un diagrama de dispersión bidimensional asignándolo a un parámetro estético. Un parámetro estético (o estética) es una propiedad visual de los objetos de un gráfico. Las estéticas incluye cosas como el tamaño, la forma o el color de tus puntos. Puedes mostrar un punto (como el siguiente) de diferentes maneras si cambias los valores de sus propiedades estéticas. Como ya usamos la palabra “valor” para describir los datos, usemos la palabra “nivel” para describir las propiedades estéticas. Aquí cambiamos los niveles del tamaño, la forma y el color de un punto para que el punto sea pequeño, triangular o azul: El mapeo entre las propiedades estéticas de tu gráfico y las variables de tu dataset te permite comunicar información sobre tus datos. Por ejemplo, puedes asignar los colores de los puntos de acuerdo a la variable clase para indicar a qué clase pertenece cada automóvil. ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista, color = clase)) (Si prefieres el inglés británico, como Hadley, puedes usar colour en lugar de color). Para mapear (o asignar) una estética a una variable, debes asociar el nombre de la estética al de la variable dentro de aes(). ggplot2 asignará automáticamente un nivel único de la estética (en este ejemplo, un color) a cada valor único de la variable. Este proceso es conocido como escalamiento (scaling). ggplot2 acompañará el gráfico con una leyenda que explica qué niveles corresponden a qué valores. Los colores revelan que muchos de los puntos inusuales son automóviles de dos asientos. ¡Estos no parecen híbridos y son, de hecho, automóviles deportivos! Los automóviles deportivos tienen motores grandes, como las camionetas todo terreno o pickups, pero su cuerpo es pequeño, como los automóviles medianos y compactos, lo que mejora su consumo de gasolina. En retrospectiva, es poco probable que estos automóviles sean híbridos, ya que tienen motores grandes. En el ejemplo anterior asignamos la variable clase a la estética de color, pero podríamos haberla asignado a la estética del tamaño del mismo modo. En este caso, el tamaño exacto de cada punto revelaría a qué clase pertenece. Recibimos aquí una advertencia (warning), porque mapear una variable no ordenada (clase) a una estética ordenada (size) no es una buena idea. ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista, size = clase)) ## Warning: Using size for a discrete variable is not advised. También podríamos haber asignado la variable clase a la estética alpha, que controla la transparencia de los puntos, o a la estética shape que controla la forma (shape) de los puntos. ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista, alpha = clase)) ## Warning: Using alpha for a discrete variable is not advised. ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista, shape = clase)) ## Warning: The shape palette can deal with a maximum of 6 discrete values because ## more than 6 becomes difficult to discriminate; you have 7. Consider ## specifying shapes manually if you must have them. ## Warning: Removed 62 rows containing missing values (geom_point). ¿Qué pasó con los SUV? ggplot2 solo puede usar seis formas a la vez. De forma predeterminada, los grupos adicionales no se grafican cuando se emplea la estética de la forma (shape). Para cada estética utilizamos aes() para asociar su nombre con la variable seleccionada para graficar. La función aes() reúne cada una de las asignaciones estéticas utilizadas por una capa y las pasa al argumento de mapeo de la capa. La sintaxis resalta una visión útil sobre x e y: las ubicaciones de x e y de un punto son en sí mismas también estéticas, es decir propiedades visuales que se puede asignar a las variables para mostrar información sobre los datos. Una vez que asignas (o “mapeas”) una estética, ggplot2 se ocupa del resto. El paquete selecciona una escala razonable para usar con la estética elegida y construye una leyenda que explica la relación entre niveles y valores. Para la estética x e y, ggplot2 no crea una leyenda, pero sí una línea que delimita el eje con sus marcas de graduación y una etiqueta. La línea del eje actúa como una leyenda; explica el mapeo entre ubicaciones y valores. También puedes fijar las propiedades estéticas de tu geom manualmente. Por ejemplo, podemos hacer que todos los puntos del gráfico sean azules: ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista), color = &quot;blue&quot;) Aquí, el color no transmite información sobre una variable, sino que cambia la apariencia del gráfico. Para establecer una estética de forma manual, debes usar el nombre de la estética como un argumento de la función geom; es decir, va fuera de aes(). Tendrás que elegir un nivel que tenga sentido para esa estética: El nombre de un color como cadena de caracteres. El tamaño de un punto en mm. La forma de un punto como un número, tal como se muestra. R tiene 25 formas predefinidas que están identificadas por números. Hay algunas que parecen duplicados: por ejemplo 0, 15 y 22 son todos cuadrados. La diferencia viene de la interacción entre las estéticas color y fill (relleno). Las formas vacías (0–14) tienen un borde determinado por color; las formas sólidas (15–18) están rellenas con color; las formas rellenas (21–24) tienen un borde de color y están rellenas por fill. Ejercicios - ¿Qué no va bien en este código? ¿Por qué hay puntos que no son azules? ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista, color = &quot;blue&quot;)) - ¿Qué variables en millas son categóricas? ¿Qué variables son continuas? (Pista: escribe ?millas para leer la documentación de ayuda para este conjunto de datos). ¿Cómo puedes ver esta información cuando ejecutas millas? - Asigna una variable continua a color, size, y shape. ¿Cómo se comportan estas estéticas de manera diferente para variables categóricas y variables continuas? - ¿Qué ocurre si asignas o mapeas la misma variable a múltiples estéticas? - ¿Qué hace la estética stroke? ¿Con qué formas trabaja? (Pista: consulta ?geom_point) - ¿Qué ocurre si se asigna o mapea una estética a algo diferente del nombre de una variable, como aes(color = cilindrada &lt; 5)? 3.8.4 Problemas comunes A medida que empieces a escribir código en R, lo más probable es que te encuentres con problemas. No te preocupes, es lo más común. Hemos estado escribiendo código en R durante años, ¡y todos los días seguimos escribiendo código que no funciona! Comienza comparando cuidadosamente el código que estás ejecutando con el código en este libro. R es extremadamente exigente y un carácter fuera de lugar puede marcar la diferencia. Asegúrate de que cada ( coincida con un ) y cada \" esté emparejado con otro\". Algunas veces ejecutarás el código y no pasará nada. Comprueba la parte izquierda de tu consola: si es un +, significa que R no cree que hayas escrito una expresión completa y está esperando que la termines. En este caso, normalmente es más fácil comenzar de nuevo desde cero presionando ESCAPE (la tecla esc) para cancelar el procesamiento del comando actual. Un problema común al crear gráficos con ggplot2 es colocar el + en el lugar equivocado: debe ubicarse al final de la línea, no al inicio. En otras palabras, asegúrate de no haber escrito accidentalmente un código como este: ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista)) Si esto no resuelve el problema, prueba con la ayuda. Puedes obtener ayuda sobre cualquier función de R ejecutando ?nombre_de_la_funcion en la consola o seleccionando el nombre de la función y presionando F1 en RStudio. No te preocupes si la ayuda no te parece tan útil, trata entonces de saltar a los ejemplos y buscar un pedazo de código que coincida con lo que intentas hacer. Si eso no ayuda, lee cuidadosamente el mensaje de error. ¡A veces la respuesta estará oculta allí! Sin embargo, cuando recién comienzas en R, puede que la respuesta esté en el mensaje de error, pero aún no sabes cómo entenderlo. Otra gran herramienta es Google: intenta buscar allí el mensaje de error, ya que es probable que otra persona haya tenido el mismo problema y haya obtenido ayuda en línea. 3.8.5 Separar en facetas Una forma de agregar variables adicionales es con las estéticas. Otra forma particularmente útil para las variables categóricas consiste en dividir el gráfico en facetas, es decir, sub-gráficos que muestran cada uno un subconjunto de los datos. Para separar en facetas un gráfico según una sola variable, utiliza facet_wrap() (del inglés envolver una faceta). El primer argumento de facet_wrap() debería ser una fórmula creada con ~ seguida del nombre de una de las variable (aquí “fórmula” es el nombre de un tipo de estructura en R, no un sinónimo de “ecuación”). La variable que uses en facet_wrap() debe ser categórica. ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista)) + facet_wrap(~ clase, nrow = 2) Para separar en facetas un gráfico según las combinaciones de dos variables, agrega facet_grid() a tu código del gráfico (grid quiere decir cuadrícula en inglés). El primer argumento de facet_grid() también corresponde a una fórmula. Esta vez, la fórmula debe contener dos nombres de variables separados por un ~. ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista)) + facet_grid(traccion ~ cilindros) Si prefieres no separar en facetas las filas o columnas, remplaza por un . el nombre de alguna de las variables, por ejemplo + facet_grid(. ~ cilindros). Ejercicios - ¿Qué ocurre si intentas separar en facetas una variable continua? - ¿Qué significan las celdas vacías que aparecen en el gráfico generado usando facet_grid(traccion ~ cilindros)? ¿Cómo se relacionan con este gráfico? ggplot(data = millas) + geom_point(mapping = aes(x = traccion, y = cilindros)) - ¿Qué grafica el siguiente código? ¿Qué hace . ? ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista)) + facet_grid(traccion ~ .) ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista)) + facet_grid(. ~ cilindros) - Mira de nuevo el primer gráfico en facetas presentado en esta sección: ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista)) + facet_wrap(~ clase, nrow = 2) ¿Cuáles son las ventajas de separar en facetas en lugar de aplicar una estética de color? ¿Cuáles son las desventajas? ¿Cómo cambiaría este balance si tuvieras un conjunto de datos más grande? - Lee ?facet_wrap. ¿Qué hace nrow? ¿Qué hace ncol? ¿Qué otras opciones controlan el diseño de los paneles individuales? ¿Por qué facet_grid() no tiene argumentos nrow y ncol? - Cuando usas facet_grid(), generalmente deberías poner la variable con un mayor número de niveles únicos en las columnas. ¿Por qué? 3.8.6 Objetos geométricos ¿En qué sentido estos dos gráficos son similares? Ambos gráficos contienen las mismas variables x e y, y ambos describen los mismos datos. Pero los gráficos no son idénticos. Cada uno utiliza un objeto visual diferente para representar los datos. En la sintaxis de ggplot2, decimos que usan diferentes geoms. Un geom es el objeto geométrico usado para representar datos de forma gráfica. La gente a menudo llama a los gráficos por el tipo de geom que utiliza. Por ejemplo, los diagramas de barras usan geoms de barra (bar), los diagramas de líneas usan geoms de línea (line), los diagramas de caja usan geoms de diagrama de caja (boxplot), y así sucesivamente. En inglés, los diagramas de puntos (llamados scatterplots) rompen la tendencia; ellos usan geom de punto (o point). Como vemos arriba, puedes usar diferentes geoms para graficar los mismos datos. La gráfica de arriba usa el geom de punto (geom_point()), y la gráfica de abajo usa el geom suavizado (geom_smooth()), una línea suavizada ajustada a los datos. Para cambiar el geom de tu gráfico, modifica la función geom que acompaña a ggplot(). Por ejemplo, para hacer los gráficos que se muestran arriba, puedes usar este código: # arriba ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista)) # abajo ggplot(data = millas) + geom_smooth(mapping = aes(x = cilindrada, y = autopista)) Cada función geom en ggplot2 toma un argumento de mapping. Sin embargo, no todas las estéticas funcionan con todos los geom. Puedes establecer la forma para un punto, pero no puedes establecer la “forma” de una línea. Por otro lado, para una línea podrías elegir el tipo de línea (linetype). geom_smooth() dibujará una línea diferente, con un tipo de línea distinto (linetype), para cada valor único de la variable que asignes al tipo de línea (linetype). ggplot(data = millas) + geom_smooth(mapping = aes(x = cilindrada, y = autopista, linetype = traccion)) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Aquí geom_smooth() separa los automóviles en tres líneas en función de su valor de traccion, que describe el tipo de transmisión de un automóvil. Una línea describe todos los puntos con un valor de 4, otra línea los de valor d, y una tercera línea describe los puntos con un valor t. Aquí, 4 significa tracción en las cuatro ruedas, d tracción delantera y t tracción trasera. Si esto suena extraño, podemos hacerlo más claro al superponer las líneas sobre los datos brutos y luego colorear todo según traccion. ¡Observa que generamos un gráfico que contiene dos geoms! Si esto te emociona, abróchate el cinturón. En la siguiente sección aprenderemos cómo colocar múltiples geoms en el mismo gráfico. ggplot2 proporciona más de 40 geoms y los paquetes de extensión proporcionan aún más (consulta https://exts.ggplot2.tidyverse.org/gallery/ para obtener una muestra). La mejor forma de obtener un panorama completo sobre las posibilidades que brinda ggplot2 es consultando la hoja de referencia (o cheatsheet), que puedes encontrar en https://rstudio.com/resources/cheatsheets/ (en la parte baja de la página encontrarás la versión en español). Para obtener más información sobre un tipo dado de geoms, usa la ayuda: ?geom_smooth. Muchos geoms, como geom_smooth(), usan un único objeto geométrico para mostrar múltiples filas de datos. Con estos geoms, puedes asignar la estética de group (grupo) a una variable categórica para graficar múltiples objetos. ggplot2 representará un objeto distinto por cada valor único de la variable de agrupamiento. En la práctica, ggplot2 agrupará automáticamente los datos para estos geoms siempre que se asigne una estética a una variable discreta (como en el ejemplo del tipo de línea o linetype). Es conveniente confiar en esta característica porque la estética del grupo en sí misma no agrega una leyenda o características distintivas a los geoms. ggplot(data = millas) + geom_smooth(mapping = aes(x = cilindrada, y = autopista)) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(data = millas) + geom_smooth(mapping = aes(x = cilindrada, y = autopista, group = traccion)) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(data = millas) + geom_smooth( mapping = aes(x = cilindrada, y = autopista, color = traccion), show.legend = FALSE ) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Para mostrar múltiples geoms en el mismo gráfico, agrega varias funciones geom a ggplot(): ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista)) + geom_smooth(mapping = aes(x = cilindrada, y = autopista)) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Esto introduce, sin embargo, cierta duplicación en nuestro código. Imagina que deseas cambiar el eje y para mostrar cilindrada en lugar de autopista. Necesitarías cambiar la variable en dos lugares y podrías olvidarte de actualizar uno. Puedes evitar este tipo de repetición pasando un conjunto de mapeos a ggplot(). ggplot2 tratará estos mapeos como **mapeos globales* que se aplican a cada geom en el gráfico. En otras palabras, este código producirá la misma gráfica que el código anterior: ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Si colocas mapeos en una función geom, ggplot2 los tratará como mapeos locales para la capa. Estas asignaciones serán usadas para extender o sobrescribir los mapeos globales solo para esa capa. Esto permite mostrar diferentes estéticas en diferentes capas. ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) + geom_point(mapping = aes(color = clase)) + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; La misma idea se puede emplear para especificar distintos conjuntos de datos (data) para cada capa. En el siguiente caso, nuestra línea suave muestra solo un subconjunto del conjunto de datos de millas: los autos subcompactos. El argumento local de datos en geom_smooth() anula el argumento de datos globales en ggplot() solo para esa capa. ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) + geom_point(mapping = aes(color = clase)) + geom_smooth(data = filter(millas, clase == &quot;subcompacto&quot;), se = FALSE) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Ejercicios - ¿Qué geom usarías para generar un gráfico de líneas? ¿Y para un diagrama de caja? ¿Y para un histograma? ¿Y para un gráfico de área? - Ejecuta este código en tu mente y predice cómo se verá el output. Luego, ejecuta el código en R y verifica tus predicciones. ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista, color = traccion)) + geom_point() + geom_smooth(se = FALSE) - ¿Qué muestra show.legend = FALSE? ¿Qué pasa si lo quitas? ¿Por qué crees que lo utilizamos antes en el capítulo? - ¿Qué hace el argumento se en geom_smooth()? - ¿Se verán distintos estos gráficos? ¿Por qué sí o por qué no? ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) + geom_point() + geom_smooth() ggplot() + geom_point(data = millas, mapping = aes(x = cilindrada, y = autopista)) + geom_smooth(data = millas, mapping = aes(x = cilindrada, y = autopista)) - Recrea el código R necesario para generar los siguientes gráficos: 3.8.7 Transformaciones estadísticas A continuación, echemos un vistazo a un gráfico de barras. Los gráficos de barras parecen simples, pero son interesantes porque revelan algo sutil sobre los gráficos. Considera un gráfico de barras básico, como uno realizado con geom_bar(). El siguiente gráfico muestra la cantidad total de diamantes en el conjunto de datos diamantes, agrupados por la variable corte. El conjunto de datos diamantes se encuentra en el paquete datos y contiene información sobre ~ 54000 diamantes, incluido el precio, el quilate, el color, la claridad y el corte de cada uno. El gráfico muestra que hay más diamantes disponibles con cortes de alta calidad que con cortes de baja calidad. ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte)) En el eje x, el gráfico muestra corte, una variable de diamantes. En el eje y muestra el recuento (count), ¡pero el recuento no es una variable en diamantes! ¿De dónde viene? Muchos gráficos, como los diagramas de dispersión (scatterplots), grafican los valores brutos de un conjunto de datos. Otros gráficos, como los de barras, calculan nuevos valores para presentar: Los gráficos de barras, los histogramas y los polígonos de frecuencia almacenan los datos y luego grafican los conteos por contenedores (bins), es decir, el número de puntos que caen en cada contenedor. Los gráficos de líneas suavizadas (smoothers) ajustan un modelo a los datos y luego grafican las predicciones del modelo. Los diagramas de caja (boxplots) calculan un resumen robusto de la distribución y luego muestran una caja con formato especial. El algoritmo utilizado para calcular nuevos valores para un gráfico se llama stat, abreviatura en inglés de transformación estadística (statistical transformation). La siguiente figura describe cómo funciona este proceso con geom_bar(). Puedes aprender acerca de qué stat usa cada geom inspeccionando el valor predeterminado para el argumento stat. Por ejemplo, ?geom_bar muestra que el valor predeterminado para stat es “count”, lo que significa que geom_bar() usa stat_count(). stat_count() está documentado en la misma página que geom_bar() y si te desplazas hacia abajo puedes encontrar una sección llamada “Computed variables” (Variables calculadas). Ahí se describe cómo calcula dos nuevas variables: count y prop. Por lo general, puedes usar geoms y estadísticas de forma intercambiable. Por ejemplo, puedes volver a crear la gráfica anterior usando stat_count() en lugar de geom_bar(): ggplot(data = diamantes) + stat_count(mapping = aes(x = corte)) Esto funciona porque cada geom tiene una estadística predeterminada y cada estadística tiene un geom predeterminado. Esto significa que generalmente puedes usar geoms sin preocuparte por la transformación estadística subyacente. Hay tres razones por las que podrías necesitar usar una estadística explícitamente: Es posible que desees anular la estadística predeterminada. En el siguiente código, cambiamos en geom_bar() la estadística recuento (“count,” el valor predeterminado) a identidad (“identity”). Esto nos permite asignar la altura de las barras a los valores brutos de una variable y. Desafortunadamente, cuando las personas hablan de gráficos de barras de manera informal, podrían estar refiriéndose a este tipo de gráfico de barras, en el que la altura de la barra ya está presente en los datos, o bien, al gráfico de barras anterior, en el que la altura de la barra se determina contando filas. demo &lt;- tribble( ~corte, ~freq, &quot;Regular&quot;, 1610, &quot;Bueno&quot;, 4906, &quot;Muy Bueno&quot;, 12082, &quot;Premium&quot;, 13791, &quot;Ideal&quot;, 21551 ) ggplot(data = demo) + geom_bar(mapping = aes(x = corte, y = freq), stat = &quot;identity&quot;) (No te preocupes si nunca has visto &lt;- o tribble(). Puede que seas capaz de adivinar su significado por el contexto y ¡pronto aprenderás qué es lo que hacen exactamente!) Es posible que desees anular el mapeo predeterminado de las variables transformadas a las estéticas. Por ejemplo, es posible que desees mostrar un gráfico de barras de proporciones, en lugar de un recuento: ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, y = stat(prop), group = 1)) Para encontrar las variables calculadas por stat, busca la sección de ayuda titulada “Compute Variables”. Es posible que desees resaltar la transformación estadística en tu código. Por ejemplo, puedes usar stat_summary(), que resume los valores de y para cada valor único de x, para así resaltar el resumen que se está computando: ggplot(data = diamantes) + stat_summary( mapping = aes(x = corte, y = profundidad), fun.min = min, fun.max = max, fun = median ) ggplot2 proporciona más de 20 transformaciones estadísticas para que uses. Cada stat es una función, por lo que puedes obtener ayuda de la manera habitual, por ejemplo: ?stat_bin. Para ver una lista completa de transformaciones estadísticas disponibles para ggplot2, consulta la hoja de referencia. Ejercicios - ¿Cuál es el geom predeterminado asociado con stat_summary()? ¿Cómo podrías reescribir el gráfico anterior para usar esa función geom en lugar de la función stat? - ¿Qué hace geom_col()? ¿En qué se diferencia de geom_bar()? - La mayoría de los geoms y las transformaciones estadísticas vienen en pares que casi siempre se usan en conjunto. Lee la documentación y haz una lista de todos los pares. ¿Qué tienen en común? - ¿Qué variables calcula stat_smooth()? ¿Qué parámetros controlan su comportamiento? - En nuestro gráfico de barras de proporción necesitamos establecer group = 1. ¿Por qué? En otras palabras, ¿cuál es el problema con estos dos gráficos? ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, y = after_stat(prop)) ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, fill = color, y = after_stat(prop)) 3.8.8 Ajustes de posición Hay una pieza más de magia asociada con los gráficos de barras. Puedes colorear un gráfico de barras usando tanto la estética de color como la más útil fill (relleno): ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, colour = corte)) ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, fill = corte)) Mira lo que sucede si asignas la estética de relleno (fill) a otra variable, como claridad: las barras se apilan automáticamente. Cada rectángulo de color representa una combinación de corte y claridad. ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, fill = claridad)) El apilamiento se realiza automáticamente mediante el ajuste de posición especificado por el argumento position. Si no deseas un gráfico de barras apiladas (“stack”), puedes usar una de las otras tres opciones: “identity,” “dodge” o “fill”. position = “identity” colocará cada objeto exactamente donde cae en el contexto del gráfico. Esto no es muy útil al momento de graficar barras, ya que las superpone. Para ver esa superposición, debemos hacer que las barras sean ligeramente transparentes configurando el alpha a un valor pequeño, o completamente transparente al establecer fill = NA. ggplot(data = diamantes, mapping = aes(x = corte, fill = claridad)) + geom_bar(alpha = 1/5, position = &quot;identity&quot;) ggplot(data = diamantes, mapping = aes(x = corte, colour = claridad)) + geom_bar(fill = NA, position = &quot;identity&quot;) El ajuste de position = identity es más útil para geoms 2D, como puntos, donde es la opción predeterminada. position = “fill” funciona como el apilamiento de position = “stack”, pero hace que cada conjunto de barras apiladas tenga la misma altura. Esto hace que sea más fácil comparar proporciones entre grupos. ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, fill = claridad), position = &quot;fill&quot;) position = “dodge” coloca los objetos superpuestos uno al lado del otro. Esto hace que sea más fácil comparar valores individuales. ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, fill = claridad), position = &quot;dodge&quot;) Hay otro tipo de ajuste que no es útil para gráficos de barras, pero que puede ser muy útil para diagramas de dispersión. Recuerda nuestro primer diagrama de dispersión. ¿Notaste que mostraba solo 126 puntos, a pesar de que hay 234 observaciones en el conjunto de datos? Los valores de las variables autopista y cilindrada se redondean de modo que los puntos aparecen en una cuadrícula y muchos se superponen entre sí. Este problema se conoce como solapamiento (overplotting). Esta disposición hace que sea difícil ver dónde está la masa de datos. ¿Los puntos de datos se distribuyen equitativamente a lo largo de la gráfica, o hay una combinación especial de autopista y cilindrada que contiene 109 valores? Puedes evitar esto estableciendo el ajuste de posición en “jitter.” position = “jitter” agrega una pequeña cantidad de ruido aleatorio a cada punto. Esto dispersa los puntos, ya que es poco probable que dos puntos reciban la misma cantidad de ruido aleatorio. ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista), position = &quot;jitter&quot;) Agregar aleatoriedad a los puntos puede parecer una forma extraña de mejorar tu gráfico. Si bien hace que sea menos preciso a escalas pequeñas, lo hace ser más revelador a gran escala. Como esta es una operación tan útil, ggplot2 incluye una abreviatura de geom_point(position = “jitter”): geom_jitter(). Para obtener más información sobre ajustes de posición, busca la página de ayuda asociada con cada ajuste: ?position_dodge, ?position_fill, ?position_identity, ?position_jitter y ?position_stack. Ejercicios - ¿Cuál es el problema con este gráfico? ¿Cómo podrías mejorarlo? ggplot(data = millas, mapping = aes(x = ciudad, y = autopista)) + geom_point() - ¿Qué parámetros de geom_jitter() controlan la cantidad de ruido? - Compara y contrasta geom_jitter() con geom_count() - ¿Cuál es el ajuste de posición predeterminado de geom_boxplot()? Crea una visualización del conjunto de datos de millas que lo demuestre. 3.8.9 Sistemas de coordenadas Los sistemas de coordenadas son probablemente la parte más complicada de ggplot2. El sistema predeterminado es el sistema de coordenadas cartesianas, donde las posiciones x e y actúan independientemente para determinar la ubicación de cada punto. Hay varios otros sistemas de coordenadas que ocasionalmente son útiles. coord_flip() cambia los ejes x e y. Esto es útil, por ejemplo, si quieres diagramas de caja horizontales. También es útil para etiquetas largas: es difícil ajustarlas sin que se superpongan en el eje x. ggplot(data = millas, mapping = aes(x = clase, y = autopista)) + geom_boxplot() ggplot(data = millas, mapping = aes(x = clase, y = autopista)) + geom_boxplot() + coord_flip() coord_quickmap() establece correctamente la relación de aspecto para los mapas. Esto es muy importante si graficas datos espaciales con ggplot2 (tema para el que, desafortunadamente, no contamos con espacio para desarrollar en este libro). nz &lt;- map_data(&quot;nz&quot;) ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = &quot;white&quot;, colour = &quot;black&quot;) ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = &quot;white&quot;, colour = &quot;black&quot;) + coord_quickmap() coord_polar() usa coordenadas polares. Las coordenadas polares revelan una conexión interesante entre un gráfico de barras y un gráfico de Coxcomb. bar &lt;- ggplot(data = diamantes) + geom_bar( mapping = aes(x = corte, fill = corte), show.legend = FALSE, width = 1 ) + theme(aspect.ratio = 1) + labs(x = NULL, y = NULL) bar + coord_flip() bar + coord_polar() Ejercicios - Convierte un gráfico de barras apiladas en un gráfico circular usando coord_polar(). - ¿Qué hace labs()? Lee la documentación. - ¿Cuál es la diferencia entre coord_quickmap() y coord_map()? - ¿Qué te dice la gráfica siguiente sobre la relación entre ciudad y autopista? ¿Por qué es coord_fixed() importante? ¿Qué hace geom_abline()? ggplot(data = millas, mapping = aes(x = ciudad, y = autopista)) + geom_point() + geom_abline() + coord_fixed() 3.8.10 La gramática de gráficos en capas En las secciones anteriores aprendiste mucho más que solo hacer diagramas de dispersión, gráficos de barras y diagramas de caja. Aprendiste una base que se puede usar para hacer cualquier tipo de gráfico con ggplot2. Para ver esto, agreguemos ajustes de posición, transformaciones estadísticas, sistemas de coordenadas y facetas a nuestra plantilla de código: ggplot(data = &lt;DATOS&gt;) + &lt;GEOM_FUNCIÓN&gt;( mapping = aes(&lt;MAPEOS&gt;), stat = &lt;ESTADÍSTICAS&gt;, position = &lt;POSICIÓN&gt; ) + &lt;FUNCIÓN_COORDENADAS&gt; + &lt;FUNCIÓN_FACETAS&gt; Nuestra nueva plantilla tiene siete parámetros que se corresponden con las palabras entre corchetes que aparecen en la plantilla. En la práctica, rara vez necesitas proporcionar los siete parámetros para hacer un gráfico porque ggplot2 proporcionará valores predeterminados útiles para todos, excepto para los datos, el mapeo y la función geom. Los siete parámetros en la plantilla componen la gramática de los gráficos, un sistema formal de construcción de gráficos. La gramática de los gráficos se basa en la idea de que puedes describir de manera única cualquier gráfico como una combinación de un conjunto de datos, un geom, un conjunto de mapeos, una estadística, un ajuste de posición, un sistema de coordenadas y un esquema de facetado. Para ver cómo funciona esto, considera cómo podrías construir un gráfico básico desde cero: podrías comenzar con un conjunto de datos y luego transformarlo en la información que deseas mostrar (con un stat). A continuación, podrías elegir un objeto geométrico para representar cada observación en los datos transformados. Luego, podrías usar las propiedades estéticas de los geoms para representar variables de los datos. Asignarías los valores de cada variable a los niveles de una estética. Posteriormente, podrías seleccionar un sistema de coordenadas para colocar los geoms. Podrías utilizar la ubicación de los objetos (que es en sí misma una propiedad estética) para mostrar los valores de las variables x e y. Ya en este punto podrías tener un gráfico completo, pero también podrías ajustar aún más las posiciones de los geoms dentro del sistema de coordenadas (un ajuste de posición) o dividir el gráfico en facetas. También podrías extender el gráfico agregando una o más capas adicionales, donde cada capa adicional usaría un conjunto de datos, un geom, un conjunto de mapeos, una estadística y un ajuste de posición. Puedes usar este método para construir cualquier gráfico que imagines. En otras palabras, puedes usar la plantilla de código que aprendiste en este capítulo para construir cientos de miles de gráficos únicos. "]]

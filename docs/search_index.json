[["programando-con-r.html", "3 Programando con R 3.1 Operadores lógicos 3.2 Consultas lógicas 3.3 Control de flujo 3.4 Funciones 3.5 Funciones de la familia apply 3.6 Gráficos 3.7 Estilo tidyverse", " 3 Programando con R 3.1 Operadores lógicos x &lt;- c(1, 2, 3, 4) Operador Resultado Comparación x &gt; 3 c(F, F, F, T, T) Mayor que x &gt;= 3 c(F, F, T, T, T) Mayor o igual que x &lt; 3 c(T, T, F, F, F) Menor que x &lt;= 3 c(T, T, T, F, F) Menor o igual que x == 3 c(F, F, T, F, F) Igual a x != 3 c(T, T, F, T, T) Diferente de x = 3 Igual que &lt;- Se puede utilizar %in% para preguntar si uno o varios elementos se encuentran en otro, devolviendo lógicos. 1 %in% c(1, 2, 3, 4) 1 %in% c(2, 3, 4) c(3,4,5,6) %in% c(2, 3, 4) Puedes combinar evaluaciones lógicas con &amp;, |, xor, !, any, y all x &gt; 2 &amp; x &lt; 9 Operador Evaluación a &amp; b Tanto a como b son VERDADEROS a | b Al menos uno de a y b es VERDADERO (o) xor(a, b) a es VERDADERO o b es VERDADERO, pero no ambos !a No a (VERDADERO va a FALSO, FALSO va a VERDADERO) any(a, b, c) Al menos uno de a, b o c es VERDADERO all(a, b, c) Cada uno de a, b y c es VERDADERO 3.2 Consultas lógicas Combinar pruebas lógicas con subconjuntos es una práctica común x_ceros &lt;- diamonds$x == 0 diamonds[x_ceros,] ## # A tibble: 8 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1.07 Ideal F SI2 61.6 56 4954 0 6.62 0 ## 2 1 Very Good H VS2 63.3 53 5139 0 0 0 ## 3 1.14 Fair G VS1 57.5 67 6381 0 0 0 ## 4 1.56 Ideal G VS2 62.2 54 12800 0 0 0 ## 5 1.2 Premium D VVS1 62.1 59 15686 0 0 0 ## 6 2.25 Premium H SI2 62.8 59 18034 0 0 0 ## 7 0.71 Good F SI2 64.1 60 2130 0 0 0 ## 8 0.71 Good F SI2 64.1 60 2130 0 0 0 # Ver resultados diamonds[diamonds$x &gt; 10, ] ## # A tibble: 5 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4.01 Premium I I1 61 61 15223 10.1 10.1 6.17 ## 2 4.01 Premium J I1 62.5 62 15223 10.0 9.94 6.24 ## 3 4 Very Good I I1 63.3 58 15984 10.0 9.94 6.31 ## 4 5.01 Fair J I1 65.5 59 18018 10.7 10.5 6.98 ## 5 4.5 Fair J I1 65.8 58 18531 10.2 10.2 6.72 # Guardar un nuevo data.frame big &lt;- diamonds[diamonds$x &gt; 10, ] # Sobreescribir el dataset existente (Cuidado!) diamonds &lt;- diamonds[diamonds$x &lt; 10,] 3.3 Control de flujo ¿Quieres saltar este capítulo? Hazlo si puedes responder estas preguntas. Cuál es la diferencia entre if e ifelse()? En el siguiente código, cuál será el valor de y si x es TRUE? Y cuál sería si x es FALSE? Y cuál si x es NA? y &lt;- if (x) 3 ¿Qué retorna de switch(\"x\", x = , y = 2, z = 3)? Los comandos de control de flujo son una forma de modificar la secuencia de ejecución del código. Existen 2 herramientas principales de flujo de control: Opciones y bucles. Las opciones, como las declaraciones condicionales if y las llamadas switch(), permiten ejecutar código diferente según la entrada. Los bucles, como for y while, le permiten ejecutar código repetidamente, generalmente con opciones cambiantes. 3.3.1 Condicionales (if, else) La toma de decisiones es una parte importante de la programación. Esto se puede lograr en la programación R usando la nomenclatura condicional if else. if (expresion) { declaracion1 }else{ declaracion2 } Si expresion es TRUE, la instrucción se ejecuta. Pero si es FALSO, no pasa nada. Aquí, expresion puede ser un vector lógico o numérico, pero solo se tiene en cuenta el primer elemento. En el caso del vector numérico, cero se toma como FALSO, el resto como VERDADERO. La parte else es opcional y solo se evalúa si expresion es FALSE. Es importante tener en cuenta que else debe estar en la misma línea que las llaves de cierre de la instrucción if. x &lt;- 0 if (x &lt; 0) { print(&quot;Numero negativo&quot;) }else if (x &gt; 0) { print(&quot;Numero positivo&quot;) } else { print(&quot;Cero&quot;) } ## [1] &quot;Cero&quot; Comparación entre Python y R ## PYTHON temp = [15, 22, 30] suelo= [&quot;seco&quot;, &quot;humedo&quot;, &quot;charcos&quot;] valtemp = temp[0] valsuelo= suelo[2] if 12&lt;= valtemp &lt; 22 and valsuelo ==&quot;seco&quot;: print(&quot;Cielo despejado&quot;) elif valtemp == 22 or valsuelo == &quot;humedo&quot;: print(&quot;lluvia leve&quot;) elif valtemp &gt; 22 and valsuelo==&quot;charcos&quot;: print(&quot;lluvia severa&quot;) else: print(&quot; Faltan datos&quot;) ## Faltan datos ## R temp &lt;- c(15, 22, 30) suelo &lt;- c(&quot;seco&quot;, &quot;humedo&quot;, &quot;charcos&quot;) valtemp &lt;- temp[1] valsuelo &lt;- suelo[3] if (valtemp %in% 12:22 &amp; valsuelo ==&quot;seco&quot;) { print(&quot;\\nCielo despejado&quot;) } else if (valtemp == 22 | valsuelo == &quot;humedo&quot;){ print(&quot;\\nlluvia leve&quot;) } else if (valtemp &gt; 22 &amp; valsuelo==&quot;charcos&quot;){ print(&quot;\\nlluvia severa&quot;) } else { print(&quot;\\nFaltan datos&quot;) } ## [1] &quot;\\nFaltan datos&quot; 3.3.2 Bucles (while, for) Los bucles son una de las estructuras fundamentales en la programación. Los bucles permiten iterar sobre cada elemento en una secuencia, uno a la vez, y hacer algo con esos elementos. 3.3.2.1 for Un bucle for es muy valioso cuando necesitamos iterar sobre una lista de elementos o un rango de números. Loop se puede usar para iterar sobre una lista, marco de datos, vector, matriz o cualquier otro objeto. Los tirantes y el corchete son obligatorios. for (valor in secuencia) { cuerpo } # Creando un vector de frutas frutas &lt;- c(&#39;Apple&#39;, &#39;Orange&#39;, &#39;Passion fruit&#39;, &#39;Banana&#39;) # Declarando el bucle for for ( i in frutas){ print(i) } ## [1] &quot;Apple&quot; ## [1] &quot;Orange&quot; ## [1] &quot;Passion fruit&quot; ## [1] &quot;Banana&quot; 3.3.2.2 while Un bucle while es una declaración que continúa ejecutándose mientras se cumple una condición. La sintaxis para un ciclo while es la siguiente: while (condición) { cuerpo } # creando la expresión con valor 1 inicio &lt;- 1 # Creando el loop while (inicio &lt;= 5){ # Ver donde estamos cat(&#39;Este es el ciclo número &#39;, inicio) # Agregar 1 a la variable inicio despues de cada iteracion inicio &lt;- inicio + 1 print(inicio) } ## Este es el ciclo número 1[1] 2 ## Este es el ciclo número 2[1] 3 ## Este es el ciclo número 3[1] 4 ## Este es el ciclo número 4[1] 5 ## Este es el ciclo número 5[1] 6 3.3.3 Controles de flujo (Break, continue, tryCatch, options) 3.4 Funciones Una función, en un entorno de programación, es un conjunto de instrucciones. Un programador crea una función para evitar repetir la misma tarea o reducir la complejidad. Una función debería ser: Escrito para llevar a cabo una tarea específica Puede o no incluir argumentos Contener un cuerpo Puede o no devolver uno o más valores function (argumentos) { # cuerpo de la funcion resultado &lt;- cuerpo return(resultado) } Ejemplo: a &lt;- 5 b &lt;- 6 suma &lt;- function(valor1, valor2){ resultado &lt;- valor1 + valor2 return(resultado) } suma(a, b) ## [1] 11 3.4.1 Ejercicios 3.4.1.1 Ejercicio 1: Cree una función que, dado un vector, imprima por pantalla la media y la desviación estándar, opcionalmente también imprimirá la mediana. 3.4.1.2 Ejercicio 2: Agregar un argumento adicional, llamado print_info, que sea TRUE por defecto Crea una condicional alrededor de la función print(), la cual debe ser ejecutada sólo si print_info es TRUE Prueba el código # Finaliza la funcion pow_two() pow_two &lt;- function(x) { y &lt;- x ^ 2 print(paste(x, &quot;to the power two equals&quot;, y)) return(y) } 3.5 Funciones de la familia apply Los apply: apply, tapply, lapply, sapply, vapply, rapply So, what are these wondrous apply functions and how do they work? I think the best way to figure out anything in R is to learn by experimentation, using embarrassingly trivial data and functions. If you fire up your R console, type “??apply” and scroll down to the functions in the base package, you’ll see something like this: d &lt;- read.csv(&quot;data/earthquakes.csv&quot;) str(d) head(d) 3.5.1 apply(): APLICA RESUMENES SOBRE MARGENES. 1=SOBRE FILAS, 2=SOBRE COLUMNAS apply(d[,2:5], 2, mean, na.rm = T) apply(d[,2:5], 2, median, na.rm = T) apply(d[,2:5], 2, summary) 3.5.2 tapply() APLICA FUNCION SOBRE MATRICES/TABLAS DESIGUALES EN LAS QUE SE USA UNA VARIABLE DE AGRUPAMIENTO O INDICE unique(d$Source) tapply(d$Magnitude, d$Latitude, mean, na.rm = T) tapply(d$Magnitude, d$Source, mean, na.rm = T) with(d, tapply(Magnitude, Latitude, mean, na.rm = T)) with(d, tapply(Magnitude, Longitude, summary)) with(d, tapply(Magnitude, Source, summary)) 3.5.3 lapply() sapply() vapply() APLICA FUNCION SOBRE VECTORES/LISTAS lapply() DEVUELVE UNA LISTA str(d) head(d) lapply(d, mean, na.rm = T) lapply(data.frame(a=10:20,b=15:25), mean) d[1:6,] d[1:6, c(12,2:5)] lapply(d[,c(12,2:5)], mean, na.rm = T) lapply(d[,c(12,2:5)], summary, na.rm = T) 3.5.4 sapply() DEVUELVE UN VECTOR O UNA TABLA levels(as.factor(d$Source)) sapply(d[,c(12,2:5)], mean, na.rm = T) sapply(d[,c(12,2:5)], summary, na.rm = T) funcion_nueva &lt;- function(x){ sapply(d[d$Source==x, c(12,2:5)], summary) } levels(as.factor(d$Source)) sapply(levels(as.factor(d$Source)), funcion_nueva, simplify = F) 3.5.5 vapply() SIMILAR, PERO DEVUELVE UNA SALIDA PREDETERMINADA QUE PODRIA RESULTAR MAS AGIL vapply(d[,c(12,2:5)], mean, na.rm = T, c(&#39;Mean&#39;=0)) vapply(d[,c(12,2:5)], fivenum, na.rm = T, c(&quot;Min.&quot;=0,&quot;1st Qu.&quot;=0, &quot;Median&quot;=0, &quot;3rd Qu.&quot;=0, &quot;Max.&quot;=0)) 3.5.6 rapply() SIMILAR, PERO DEVUELVE UNA SALIDA QUE PUEDE CONSERVAR ESTRUCTURA ORIGINAL O LISTA rapply(d[,2:5], summary) rapply(d[,2:5], summary, how = &#39;list&#39;) Para profundizar, se recomienda seguir esta Fuente 3.6 Gráficos # Scatter plots x &lt;- 1:12 y &lt;- c(27, 28, 26, 22, 19, 16, 14, 13, 14, 16, 20, 23) estaciones &lt;- c(rep(&quot;verano&quot;,2), rep(&quot;otoño&quot;,3), rep(&quot;invierno&quot;,3), rep(&quot;primavera&quot;,3), &quot;verano&quot;) df &lt;- data.frame(x, y, estaciones) plot(df$x, df$y, type=&quot;o&quot;, pch=14,xlab = &quot;Mes&quot;, ylab = &quot;Temperatura [°C]&quot;, main=&quot;Lima, Temperatura mensual promedio&quot;) plot(df$x, df$y, type=&quot;o&quot;, pch=20, xlab=&quot;Mes&quot;, ylab=&quot;Temperatura [°C]&quot;, main=&quot;Lima, Temperatura mensual promedio&quot;, col = &quot;#F47E40&quot;) df[&quot;colores&quot;] = c(rep(&quot;black&quot;,2), rep(&quot;green&quot;,3), rep(&quot;red&quot;,3), rep(&quot;blue&quot;,3), &quot;red&quot;) legend(&quot;top&quot;, legend = levels(factor(estaciones)), col = c(&quot;black&quot;, &quot;green&quot;, &quot;red&quot;, &quot;blue&quot;), pch = c(16, 17, 18) ) data(cars) plot(cars$speed, cars$dist, xlab = &quot;Velocidad&quot;, ylab = &quot;Distancia&quot;, main = &quot;Velocidad vs distancia&quot;) # Histogram # hist(cars$speed) # hist(cars$speed, breaks = 10) hist(cars$dist, freq = T, col = &quot;skyblue&quot;, labels = T) 3.7 Estilo tidyverse Primero necesitarás instalar algunos paquetes de R. Un paquete R es una colección de funciones, datos y documentación que amplía las capacidades de R base. El uso de paquetes es clave para el uso exitoso de R. La mayoría de los paquetes que aprenderá en este apartado son parte del llamado tidyverse. Los paquetes de tidyverse comparten una filosofía común de programación de datos y R, y están diseñados para trabajar juntos de forma natural. Puedes instalar tidyverse completo con una sola línea de código: install.packages(\"tidyverse\") "]]
